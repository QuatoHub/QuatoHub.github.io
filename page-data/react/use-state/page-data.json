{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/react/use-state/",
    "result": {"data":{"posts":{"edges":[{"node":{"id":"ee4fd426-af5b-5167-bfc3-128e79f6f97b","html":"<h1>들어가며</h1>\n<p><a href=\"https://react.vlpt.us/\" target=\"_blank\" rel=\"nofollow\">벨로퍼트와 함께하는 모던 리액트</a>의 <a href=\"https://react.vlpt.us/basic/07-useState.html\" target=\"_blank\" rel=\"nofollow\">useState 를 통해 컴포넌트에서 바뀌는 값 관리하기</a>를 읽고 정리한 글입니다. 이벤트 함수를 호출할 때 차이, 배열 비구조화 할당 및 <strong>최적화를 고려한 useState 사용 방법</strong>에 대해 정리했습니다. <code>+1</code> 버튼과 <code>-1</code>버튼이 있는 Counter 예제를 사용했습니다.</p>\n<h1>📝 useState의 개념</h1>\n<p>컴포넌트에서 보여줘야 하는 내용이 사용자 인터랙션에 따라 바뀌어야 할 때 useState 를 사용할 수 있습니다. Hooks 라는 기능이 도입되면서 함수형 컴포넌트에서도 상태를 관리할 수 있게 되었습니다. useState 는 리액트의 Hooks 중 하나입니다.</p>\n<h2>🎯 이벤트 설정할 때 함수 호출 방법의 차이</h2>\n<p>리액트에서 엘리먼트에게 이벤트를 설정해줄 때에는 on이벤트이름={실행하고 싶은 함수} 형태로 설정해주어야 합니다. 주의해야 하는 점은, 함수 형태를 넣어주어야 하지, 함수를 다음과 같이 실행하면 안 됩니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">onClick={onIncrease}       // ( O )\nonClick={onIncrease()}     // ( X )</code>\n        </deckgo-highlight-code>\n<p>이렇게 하면 렌더링 되는 시점에서 함수가 호출돼버리기 때문입니다.</p>\n<h2>🎯 배열 비구조화 할당을 적용한 useState</h2>\n<p>useState 를 사용 할 때는 상태의 기본값을 파라미터로 넣어서 호출해줍니다. 이 함수를 호출해주면 배열이 반환되는데요, 여기서 첫 번째 원소는 현재 상태, 두 번째 원소는 Setter 함수입니다. 원래는 아래 코드와 같이 useState 함수를 사용해야 하지만</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const numberState = useState(0);\nconst number = numberState[0];\nconst setNumber = numberState[1];</code>\n        </deckgo-highlight-code>\n<p>배열 비구조화 할당을 통해 각 원소를 추출하여 아래 코드와 같이 useState를 사용할 수 있습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const [number, setNumber] = useState(0);</code>\n        </deckgo-highlight-code>\n<h2>🎯 함수형 업데이트로 최적화 고려하기</h2>\n<p>Setter 함수를 사용할 때, 기존 값을 어떻게 업데이트할지에 대한 함수를 등록하는 방식으로 값을 업데이트할 수 있습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">setNumber(prevNumber =&gt; prevNumber + 1);</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">setNumber(prevNumber =&gt; prevNumber - 1);</code>\n        </deckgo-highlight-code>\n<p>setNumber 를 사용할 때 그다음 상태를 파라미터로 넣어준 것이 아니라, 값을 업데이트하는 함수를 파라미터로 넣어주었습니다. 함수형 업데이트는 주로 나중에 컴포넌트를 최적화를 하게 될 때 사용하게 됩니다.</p>\n<h3>🔎 Counter.js Code</h3>\n<p><code>button</code>의 <code>onClick</code>으로 각 함수를 연결해주었습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">import React, { useState } from &#39;react&#39;;\n\nfunction Counter() {\n  const [number, setNumber] = useState(0);\n\n  const onIncrease = () =&gt; {\n    setNumber(prevNumber =&gt; prevNumber + 1);\n  };\n\n  const onDecrease = () =&gt; {\n    setNumber(prevNumber =&gt; prevNumber - 1);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{number}&lt;/h1&gt;\n      &lt;button onClick={onIncrease}&gt;+1&lt;/button&gt;\n      &lt;button onClick={onDecrease}&gt;-1&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default Counter;</code>\n        </deckgo-highlight-code>\n<h3>💻 실행 결과</h3>\n<p><img src=\"https://images.velog.io/images/mnz/post/cc0f7897-99bb-489e-a038-41691c92be39/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202021-04-18%20150005.png\" alt=\"img\"></p>\n<h1>마치며</h1>\n<p>이벤트 함수를 호출할 때 차이, 배열 비구조화 할당 및 최적화를 고려한 useState 사용 방법에 대해 정리했습니다. 함수형 업데이트를 주로 컴포넌트 최적화할 때 사용하는 이유에 대해서는 최적화 포스팅에서 다루겠습니다. useState 를 통해 컴포넌트에서 바뀌는 값 관리하기 관련 추가 내용은 <a href=\"https://react.vlpt.us/basic/07-useState.html\" target=\"_blank\" rel=\"nofollow\">useState 를 통해 컴포넌트에서 바뀌는 값 관리하기</a> 링크에서 확인하실 수 있습니다.</p>\n<hr />\n<h3>참고 자료 📩</h3>\n<ul>\n<li><a href=\"https://react.vlpt.us/basic/07-useState.html\" target=\"_blank\" rel=\"nofollow\">useState 를 통해 컴포넌트에서 바뀌는 값 관리하기</a></li>\n</ul>","timeToRead":2,"frontmatter":{"title":"[React] 최적화를 고려하며 useState 사용하기","summary":"벨로퍼트와 함께하는 모던 리액트의 \"useState 를 통해 컴포넌트에서 바뀌는 값 관리하기\"를 읽고 정리한 글입니다.","date":"18 April, 2021","category":"React","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACIUlEQVQoz1WS2W7UQBRELV4ydru77V7cttt2PFsyWSaAWEMSBQKIsL8idv7/Iw7CIAEPJd2Xe+5VVSXD5gDXdmjn0dZReI+uaqTzZFqTSsVMKnZEjnYGXTl2hGCW5+ykKalxqL0jVN2hTEViFnv4fo6rG6o44OoW42syVZApjXR2knIW0wS0dxNsJn4DxWKNvHOKvneBinMSYzzzcclic0C7OcIfrLFjjV+2FLFiZiWpU6RWcWM2Q2g9HdrJBCIOyEeXiGdvSM+eksWRJDeOcbvP5v4R/XZkOJ4T1pGi9wz7Sz58+syj80senJ7z5Olzmr6fLEhFjlztI88ek169JDt9jFzuk6TGMF+sWR7eJK5WdONAGEdy76n7gS/ff/Dx6zc+f/vOq3fvqbt++jATEuED8vyK7OIK9fACGyNJ6i1Ns0s/X9LEDls1mNBS+oCrI2WIDOOcEPvJZxNq8sIgckne9ojjW+T3zzDzBZUpSDJvyNsV7ckZd2/fZL054HC75fhky9HJLV68fsfz61dcXj3j+vVb9g6PSXOF1AahS7LSkblfYVXUIZCIyqKbkWq1ZXe1R9vv4kKDMh5lPbJ0qF/VMH9nWRgyWSBkgdQlznq62NF1A4lqA5m2SOMQhUVoQ17YP8t+6pb+R6p0lC7gm0gdO+rYU7Y92jfkQpPI4JFxSVgd4ut28lDb6n+Y/QuUhcOFdpIsLGkcmfUrsjKQS8NPvZIF0F/jnCkAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/265d4e6aae2af2a8cb0d1dcd5945241c/25b42/use-state.png","srcSet":"/static/265d4e6aae2af2a8cb0d1dcd5945241c/f144d/use-state.png 183w,\n/static/265d4e6aae2af2a8cb0d1dcd5945241c/50beb/use-state.png 365w,\n/static/265d4e6aae2af2a8cb0d1dcd5945241c/25b42/use-state.png 730w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/static/265d4e6aae2af2a8cb0d1dcd5945241c/c97dd/use-state.webp 183w,\n/static/265d4e6aae2af2a8cb0d1dcd5945241c/2772f/use-state.webp 365w,\n/static/265d4e6aae2af2a8cb0d1dcd5945241c/c85f2/use-state.webp 730w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":365}},"publicURL":"/static/265d4e6aae2af2a8cb0d1dcd5945241c/use-state.png"}}}}]}},"pageContext":{"slug":"/react/use-state/"}},
    "staticQueryHashes": ["2368566813","3026479947","3227158195","413061808"]}