{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/react/input-immutable/",
    "result": {"data":{"posts":{"edges":[{"node":{"id":"e58b642a-ac13-50de-937a-ceff69372323","html":"<h1>들어가며</h1>\n<p><a href=\"https://react.vlpt.us/\" target=\"_blank\" rel=\"nofollow\">벨로퍼트와 함께하는 모던 리액트</a>의 <a href=\"https://react.vlpt.us/basic/08-manage-input.html\" target=\"_blank\" rel=\"nofollow\">input 상태 관리하기</a>와 <a href=\"https://react.vlpt.us/basic/09-multiple-inputs.html\" target=\"_blank\" rel=\"nofollow\">여러개의 input 상태 관리하기</a>를 읽고 정리한 글입니다. <strong>input 관리하는 방법</strong>, <strong>불변성을 지키며 여러 개의 input 객체로 관리하는 방법</strong>에 대해 정리했습니다. 사용자에게 이름과 닉네임을 입력받는 예제를 사용했습니다.</p>\n<h1>📝 useState의 개념</h1>\n<p>컴포넌트에서 보여줘야 하는 내용이 사용자 인터랙션에 따라 바뀌어야 할 때 useState 를 사용할 수 있습니다. Hooks 라는 기능이 도입되면서 함수형 컴포넌트에서도 상태를 관리할 수 있게 되었습니다. useState 는 리액트의 Hooks 중 하나입니다.</p>\n<h2>🎯 이벤트 등록하기</h2>\n<p>이벤트에 등록하는 함수에서는 이벤트 객체 <code>e</code>를 파라미터로 받아와서 사용할 수 있습니다. 이 객체의 <code>e.target</code>은 이벤트가 발생한 DOM 인 input DOM 을 가리키게 됩니다. 이 DOM 의 <code>value</code>값, 즉 <code>e.target.value</code>를 조회하면 현재 <code>input</code>에 입력한 값이 무엇인지 알 수 있습니다. 값 하나를 입력받는 InputSample 컴포넌트를 통해 알아보겠습니다.</p>\n<h3>🔎 InputSample.js Code</h3>\n<p><code>e.target.value</code>로 <code>input</code>값에 접근한 후 setText 를 통해 <code>text</code>값을 업데이트했습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">import React, { useState } from &#39;react&#39;;\n\nfunction InputSample() {\n  const [text, setText] = useState(&#39;&#39;);\n\n  const onChange = e =&gt; {\n    setText(e.target.value);\n  };\n\n  const onReset = () =&gt; {\n    setText(&#39;&#39;);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;input onChange={onChange} value={text} /&gt;\n      &lt;button onClick={onReset}&gt;초기화&lt;/button&gt;\n      &lt;div&gt;\n        &lt;b&gt;값: {text}&lt;/b&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default InputSample;</code>\n        </deckgo-highlight-code>\n<h3>💻 실행 결과</h3>\n<p>입력한 값을 값: {text} 부분에서 확인할 수 있습니다.</p>\n<p><img src=\"https://images.velog.io/images/mnz/post/587039a7-c908-4675-bba9-ecb8a04843f1/image.png\" alt=\"img\"></p>\n<h1>📖 여러 개의 input 관리하는 방법</h1>\n<p><code>input</code>의 개수가 여러 개가 됐을 때는, useState 를 여러 번 사용하고 onChange 도 여러 개 만들어서 구현할 수 있습니다. 이 글에서 소개할 더 좋은 방법은, <code>input</code>에 <code>name</code>을 설정하고 이벤트가 발생했을 때 이 값을 참조하는 것입니다. 또한, useState 에서는 문자열이 아니라 객체 형태의 상태를 관리해주어야 합니다.</p>\n<h2>📢 초깃값을 객체로 선언하기</h2>\n<p>useState 함수를 사용하며 초깃값을 선언할 때, 객체로 선언하여 사용합니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const [inputs, setInputs] = useState({\n  name: &#39;&#39;,\n  nickname: &#39;&#39;,\n});</code>\n        </deckgo-highlight-code>\n<h2>✨ 비구조화 할당으로 값 추출해서 사용하기</h2>\n<p>name 값과 nickname 값을 비구조화 할당을 통해 <code>inputs</code>에서 추출해서 사용할 수 있습니다. 필수적인 과정은 아니지만, 추후 name 과 nickname 값에 편하게 접근하기 위해 작성한 코드입니다. 이 과정을 생략하고 name 값과 nickname 값에 접근하려면 <code>inputs.name</code> <code>inputs.nickname</code>과 같이 접근할 수 있습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const { name, nickname } = inputs;</code>\n        </deckgo-highlight-code>\n<p>같은 방법으로 <code>e.target.name</code>과 <code>e.target.value</code>를 추출했습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const { name, value } = e.target;</code>\n        </deckgo-highlight-code>\n<h2>✍ 리액트 상태에서 불변성 지키며 객체 수정하기</h2>\n<p>리액트 상태에서 객체를 수정해야 할 때는</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">inputs[name] = value;</code>\n        </deckgo-highlight-code>\n<p>이런 식으로 직접 수정하지 않고, 새로운 객체를 생성합니다. 새로운 객체에 변화를 주고, 이를 상태로 사용합니다. 이러한 작업을, “불변성을 지킨다.” 라고 부릅니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">setInputs({\n  ...inputs,\n  [name]: value,\n});</code>\n        </deckgo-highlight-code>\n<p>…inputs 를 통해 기존의 <code>inputs</code>객체를 복사한 후 [name]: value 에서 name 키를 가진 값을 <code>value</code>로 설정했습니다.</p>\n<h2>🧐 새로운 객체를 생성한 코드에 대해 자세히 알아보기</h2>\n<p>위 코드에서 사용한 name 과 value 는 위에서 비구조화 할당을 통해 추출한 <code>e.target.name</code>과 <code>e.target.value</code>입니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const { name, value } = e.target;</code>\n        </deckgo-highlight-code>\n<p><code>e.target.name</code>에 해당하는 값은 input name=“name” 또는 input name=“nickname” 을 판단할 수 있습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">&lt;input name=&quot;name&quot; placeholder=&quot;이름&quot; onChange={onChange} value={name} /&gt;\n&lt;input name=&quot;nickname&quot; placeholder=&quot;닉네임&quot; onChange={onChange} value={nickname} /&gt;</code>\n        </deckgo-highlight-code>\n<p>따라서 name 값을 key 값으로 사용하고 해당하는 value 값을 onChange 함수 setInputs 에 사용합니다.</p>\n<h2>⭐ 리액트에서 불변성을 지키는 이유</h2>\n<p>불변성을 지켜주어야만 리액트 컴포넌트에서 상태가 업데이트됐음을 감지할 수 있고 이에 따라 필요한 리렌더링이 진행됩니다. 기존 상태를 직접 수정하게 되면, 값을 바꿔도 리렌더링이 되지 않습니다. 리액트에서는 불변성을 지켜주어야만 컴포넌트 업데이트 성능 최적화를 제대로 할 수 있습니다.</p>\n<h3>🔎 InputSample.js Code</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">import React, { useState } from &#39;react&#39;;\n\nfunction InputSample() {\n  const [inputs, setInputs] = useState({\n    name: &#39;&#39;,\n    nickname: &#39;&#39;,\n  });\n\n  const { name, nickname } = inputs;\n\n  const onChange = e =&gt; {\n    const { name, value } = e.target;\n\n    setInputs({\n      ...inputs,\n      [name]: value,\n    });\n  };\n\n  const onReset = () =&gt; {\n    setInputs({\n      name: &#39;&#39;,\n      nickname: &#39;&#39;,\n    });\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;input name=&quot;name&quot; placeholder=&quot;이름&quot; onChange={onChange} value={name} /&gt;\n      &lt;input\n        name=&quot;nickname&quot;\n        placeholder=&quot;닉네임&quot;\n        onChange={onChange}\n        value={nickname}\n      /&gt;\n      &lt;button onClick={onReset}&gt;초기화&lt;/button&gt;\n      &lt;div&gt;\n        &lt;b&gt;{name} &lt;/b&gt;({nickname})\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default InputSample;</code>\n        </deckgo-highlight-code>\n<h3>💻 실행 결과</h3>\n<p><img src=\"https://images.velog.io/images/mnz/post/a5a7d597-ac76-4e2f-bc5e-7eb8fc5e6257/image.png\" alt=\"img\"></p>\n<h1>마치며</h1>\n<p>불변성을 지키며 여러 개의 input 객체로 관리하는 방법에 대해 정리했습니다. 그 과정에서 초깃값을 객체로 선언하는 방법, 비구조화 할당으로 값 추출해서 사용하는 방법, 리액트 상태에서 불변성 지키며 객체 수정하는 방법 및 리액트에서 불변성을 지키는 이유에 대해 알아봤습니다. input 관련 추가 내용은 <a href=\"https://react.vlpt.us/basic/08-manage-input.html\" target=\"_blank\" rel=\"nofollow\">input 상태 관리하기</a>와 <a href=\"https://react.vlpt.us/basic/09-multiple-inputs.html\" target=\"_blank\" rel=\"nofollow\">여러개의 input 상태 관리하기</a> 링크에서 확인하실 수 있습니다.</p>\n<hr />\n<h3>참고 자료 📩</h3>\n<ul>\n<li>\n<p><a href=\"https://react.vlpt.us/basic/08-manage-input.html\" target=\"_blank\" rel=\"nofollow\">input 상태 관리하기</a></p>\n</li>\n<li>\n<p><a href=\"https://react.vlpt.us/basic/09-multiple-inputs.html\" target=\"_blank\" rel=\"nofollow\">여러개의 input 상태 관리하기</a></p>\n</li>\n</ul>","timeToRead":4,"frontmatter":{"title":"[React] input 값 불변성 지키며 객체로 관리하기","summary":"벨로퍼트와 함께하는 모던 리액트의 \"input 상태 관리하기\"와 \"여러개의 input 상태 관리하기\"를 읽고 정리한 글입니다.","date":"20 April, 2021","category":"React","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACMklEQVQozzWS227bRhBAiT5UJJe7S+6FtyUpSqJlO45Tw0XcOrZgR3bSBmmTPhZI06Tp/3/DKcSkD+dhBpgzg5mJhpNTXNuhnUdbR+49uqyRzpNqTSIVsVQsRIZ2Bl06FkIQZxmLJCExDrU9Q9UdypREZr3F9ytc3VCGAVe3GF+TqpxUaaSzqG+YpkJ7N8ti8VUo1kfIH6/Rz3eosCIyxrMaN6xPTmlPzvCnR9ixxm9a8lASW0niFLFVfBfHCK3nRotUIMKAfHGHePyN5OaBNIxEmXGM58ecXJ3Rn48MT1dUR4GiLxmOJ/788JEXuzt+ur7l5cMrmr6f15CIDDkdI2/uSfZvSK/vkZtjosQYVusjNk9+IEwT3Tjgh4HUWqqu469Pn/nw9yc+fv6Ht+/+oAod36eC+DBhWSFv96S7PernHTYEosRbmmZJv97QhH7eX7tc0fRL2mGk7lfUbUfuKwpfzflx2mKsQ7Qd2dMLsqsbzGpNaXKi1BuydqJ9dsPzyws22y37x0e+/PuFV7+84fLqmv3ja3b3e27vXvLw+lfe/v6eZxeXLIREGE/qDscqqauKSJQW3YyU0znLaUsYlpiyRtsSZRyycGS5nTnEyniEKkgyjZA5Uhc46+lCR9cNRKqtSLVFGofILUIbssLOokPxgYN85hAXjsJVlE2gDh116CnaHu0bMqGJZOWRYUM1PcHXLbZsvk3n50fV5n/ZV1TucFU7I3NLEkbifiItKjJp+A+umghem31HlgAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/57b8ed80eba54d748ac527a810631722/25b42/input-immutable.png","srcSet":"/static/57b8ed80eba54d748ac527a810631722/f144d/input-immutable.png 183w,\n/static/57b8ed80eba54d748ac527a810631722/50beb/input-immutable.png 365w,\n/static/57b8ed80eba54d748ac527a810631722/25b42/input-immutable.png 730w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/static/57b8ed80eba54d748ac527a810631722/c97dd/input-immutable.webp 183w,\n/static/57b8ed80eba54d748ac527a810631722/2772f/input-immutable.webp 365w,\n/static/57b8ed80eba54d748ac527a810631722/c85f2/input-immutable.webp 730w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":365}},"publicURL":"/static/57b8ed80eba54d748ac527a810631722/input-immutable.png"}}}}]}},"pageContext":{"slug":"/react/input-immutable/"}},
    "staticQueryHashes": ["2368566813","3026479947","3227158195","413061808"]}