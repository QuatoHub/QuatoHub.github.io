{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/CodeStates/2021-11-15-CodeStates IM [week 7]/",
    "result": {"data":{"posts":{"edges":[{"node":{"id":"317183cd-5133-520c-a82e-58676c4cda1f","html":"<h2>📆   2021. 11. 15 (월)</h2>\n<h3><span>[Database] 정규화</span></h3>\n<p> </p>\n<p><strong>데이터베이스 정규화 (Database Normalization)</strong></p>\n<p>데이터베이스 정규화는 데이터베이스의 설계와 관련 있다. 데이터베이스 설계에 따라 데이터가 어떻게 저장될지 그 구조를 결정하기 때문이다.</p>\n<p>이를 위해서는 크게 다음 부분들이 중요하다 :</p>\n<ul>\n<li>Data redundancy</li>\n<li>Data integrity</li>\n<li>Anomaly</li>\n</ul>\n<p> </p>\n<p><strong>Data Redundancy</strong></p>\n<p>데이터 중복(data redundancy)은 실제 데이터의 동일한 복사본이나, 부분적인 복사본을 뜻한다.\n물론 이러한 중복으로 데이터를 복구할 때에 더 수월할 수도 있다. 그러나 대체로 데이터베이스 내에서는 몇 가지 문제점을 지닌다.</p>\n<ul>\n<li>일관된 자료 처리의 어려움</li>\n<li>저장 공간 낭비</li>\n<li>데이터 효율성 감소</li>\n</ul>\n<p> </p>\n<p><strong>Data Integrity</strong></p>\n<p>데이터 정규화는 데이터 무결성을 강화하는 목적도 지닌다.</p>\n<p>데이터 무결성(data integrity)은 데이터의 수명 주기 동안 정확성과 일관성을 유지하는 것을 뜻한다.\n다시 말해 입력된 데이터가 오염되지 않고, 입력된 그대로 데이터를 사용할 수 있다는 뜻이다.</p>\n<p> </p>\n<p><strong>Anomaly</strong></p>\n<p>데이터 이상 현상(anomaly)은 기대한 데이터와 다른, 이상 현상을 가리킨다.</p>\n<p>다음과 같은 3가지 현상이 있다:</p>\n<ul>\n<li>\n<p>갱신 이상(update anomaly)</p>\n</li>\n<li>\n<p>삽입 이상(insertion anomaly)</p>\n</li>\n<li>\n<p>삭제 이상(deletion anomaly)</p>\n</li>\n<li>\n<p>Update Anomaly</p>\n</li>\n</ul>\n<p>갱신 이상(update anomaly)은 여러 행(레코드)에 걸쳐 동일한 데이터가 있을 때, 어떤 행을 갱신해야 하는지 논리적인 일관성이 없는 경우에 발생한다.</p>\n<p>다음과 같은 테이블이 존재하고 두 개의 레코드가 동일한 사람일 때, 519번을 갱신하는 경우 어떤 행의 데이터를 갱신해야 하는지 알 수 없다.</p>\n<p><img src=\"https://images.velog.io/images/quato/post/392af426-31b1-4dc0-b5a8-df3c10148684/image.png\" alt=\"\"></p>\n<ul>\n<li>Insertion Anomaly</li>\n</ul>\n<p>삽입 이상(insertion anomaly)은 데이터를 삽입하지 못하는 경우를 가리킨다.\n다음과 같은 경우 새로운 직원이 들어왔을 때, Dr. Newsome이 가르칠 수업이 아직 정해지지 않았다면 데이터를 추가하지 못한다.</p>\n<p>수업을 NULL 값으로 지정하지 않는 이상, 담당 수업이 있어야만 테이블에 추가할 수 있는 이상 현상이 발생한다.</p>\n<p><img src=\"https://images.velog.io/images/quato/post/2fbd4c29-7137-469c-a08f-e1744d00317f/image.png\" alt=\"\"></p>\n<ul>\n<li>Deletion Anomaly</li>\n</ul>\n<p>삭제 이상(deletion anomaly)은 데이터의 특정 부분을 지울 때 의도치 않게 다른 부분도 함께 지우는, 이상 현상이다.</p>\n<p>다음과 같은 경우 한 직원이 담당하는 수업을 삭제합니다. 그러나 이 수업 데이터를 삭제하려면, 레코드 전체가 사라집니다. 결국에는 의도치 않게 직원의 다른 데이터도 함께 삭제되는 현상이 발생한다.</p>\n<p><img src=\"https://images.velog.io/images/quato/post/81037d41-0286-401d-b7f5-4e15a411162f/image.png\" alt=\"\"></p>\n<p> </p>\n<h2>📆   2021. 11. 15 (화)</h2>\n<h3><span>[Database] MVC design pattern</span></h3>\n<p> </p>\n<p><strong>1. MVC 패턴 구조Permalink</strong></p>\n<p>MVC 패턴은 이름에서도 알 수 있듯이 모델(Model), 뷰(View), 컨트롤러(Controller) 세 개의 컴포넌트로 이루어졌다. 각 컴포넌트는 고유한 역할을 수행한다.</p>\n<p>MVC 패턴 다이어그램 및 웹 어플리케이션에서 사용하는 일반적인 MVC 패턴Permalink</p>\n<p><img src=\"https://images.velog.io/images/quato/post/5d2039cc-472b-4865-903e-8db642ad46b9/image.png\" alt=\"\"></p>\n<p> </p>\n<p><strong>1.1. 모델(Model)Permalink</strong></p>\n<blockquote>\n<p>DATA, 정보들의 가공을 책임지는 컴포넌트를 말한다.</p>\n</blockquote>\n<p>모델(Model)은 어플리케이션의 정보, 데이터를 나타낸다. 데이타베이스, 처음의 정의하는 상수, 초기화 값, 변수 등을 뜻한다. 비즈니스 로직을 처리한 후 모델의 변경사항을 컨트롤러와 뷰에 전달한다.</p>\n<p>모델은 다음과 같은 규칙을 가지고 있다.</p>\n<ul>\n<li>사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 한다.</li>\n<li>뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 한다.</li>\n<li>변경이 일어나면, 변경 통지에 대한 처리 방법을 구현해야만 힌다.</li>\n</ul>\n<p> </p>\n<p><strong>1.2. 뷰(View)Permalink</strong></p>\n<blockquote>\n<p>사용자에게 보여지는 부분, 즉 유저 인터페이스(User interface)를 의미한다.</p>\n</blockquote>\n<p>MVC 패턴은 여러 개의 뷰(View)가 존재할 수 있으며, 모델에게 질의하여 데이터를 전달받는다. 뷰는 받은 데이터를 화면에 표시해주는 역할을 가지고 있다. 모델에게 전달받은 데이터를 별도로 저장하지 않아야 한다. 사용자가 화면에 표시된 내용을 변경하게 되면 모델에게 전달하여 모델을 변경해야 한다.</p>\n<p>뷰는 다음과 같은 규칙을 가지고 있다.</p>\n<ul>\n<li>모델이 가지고 있는 정보를 따로 저장해서는 안된다.</li>\n<li>모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 된다.</li>\n<li>변경이 일어나면 변경통지에 대한 처리방법을 구현해야만 한다.</li>\n</ul>\n<p> </p>\n<p><strong>1.3. 컨트롤러(Controller)Permalink</strong></p>\n<blockquote>\n<p>모델(Model)과 뷰(View) 사이를 이어주는 브릿지(Bridge) 역할을 의미한다.</p>\n</blockquote>\n<p>모델이나 뷰는 서로의 존재를 모르고 있다. 변경 사항을 외부로 알리고 수신하는 방법만 있다. 컨트롤러(Controller)는 이를 중재하기 위해 모델과 뷰에 대해 알고 있어야 한다. 모델이나 뷰로부터 변경 내용을 통지 받으면 이를 각 구성 요소에게 통지해야 한다. 사용자가 어플리케이션을 조작하여 발생하는 변경 이벤트들을 처리하는 역할을 수행한다.</p>\n<p>컨트롤러는 다음과 같은 규칙을 가지고 있다.</p>\n<ul>\n<li>모델이나 뷰에 대해서 알고 있어야 한다.</li>\n<li>모델이나 뷰의 변경을 모니터링 해야 한다.</li>\n</ul>\n<p> </p>\n<p><strong>2. MVC 패턴 왜 사용할까?Permalink</strong></p>\n<p>MVC 패턴에 대한 여러 글을 읽어봤지만, 결국 ‘유지보수의 편리성’이라는 하나의 결론으로 수렴한다. 최초 설계를 꼼꼼하게 진행한 시스템이라도 유지보수가 발생하기 시작하면 각 기능간의 결합도(coupling)가 높아지는 경우가 발생한다. 이는 최초 설계 이념을 정했던 사람들의 부재 혹은 비즈니스 요건 변경으로 인해 필연적으로 발생하는 것 같다. 결합도가 높아진 시스템은 유지보수 작업 시 다른 비즈니스 로직에 영향을 미치게 되므로 사소한 코드의 변경이 의도치 않은 버그를 유발할 수 있다.</p>\n<p>선배 개발자들은 이런 문제점을 해결하기 위해 UI 시스템의 핵심 컴포넌트를 모델, 뷰, 컨트롤러로 나누고 각 컴포넌트가 자신의 수행 결과를 다른 컴포넌트에게 전달하는 프로그래밍 방식을 만들었다. MVC 패턴을 가진 시스템의 각 컴포넌트는 자신이 맡은 역할만 수행한 후 다른 컴포넌트로 결과만 넘겨주면 되기 때문에 시스템 결합도를 낮출 수 있다. 유지보수 시에도 특정 컴포넌트만 수정하면 되기 때문에 보다 쉽게 시스템 변경이 가능하다. (화면의 변경은 only 뷰, 데이터나 비즈니스 요건이 변경은 only 모델, 뷰와 모델 변경에 따른 일부 컨트롤러 변경)</p>\n<p> </p>\n<p><strong>3. MVC 패턴의 한계Permalink</strong></p>\n<p>세상에 완벽이라는 단어는 없다. MVC 패턴에도 한계가 존재한다. 복잡한 대규모 프로그램의 경우 다수의 뷰와 모델이 컨트롤러를 통해 연결되기 때문에 컨트롤러가 불필요하게 커지는 현상이 발생한다. 복잡한 화면을 구성하는 경우에도 동일한 현상이 발생하는데 이를 ‘Massive-View-Controller’ 라고 한다.</p>\n<p><img src=\"https://images.velog.io/images/quato/post/b32611f1-7764-41e5-bfe3-5ccd15289ac4/image.png\" alt=\"\"></p>\n<p> </p>\n<h2>📆   2021. 11. 16 (수)</h2>\n<h3><span>[Database] 개인 학습</span></h3>\n<p> </p>\n<p>어제 스프린트를 모두 마무리하여 오늘은 페어와 상의 후 개인 학습을 진행했다. 어제 학습한 MVC 패턴을 바탕으로 스프린트를 한번 더 복습했으며 내일 진도인 ORM에 대한 강좌를 학습했다.</p>\n<p> </p>\n<h2>📆   2021. 11. 17 (목)</h2>\n<h3><span>[Database] ORM</span></h3>\n<p> </p>\n<p><strong>1 영속성(Persistence)이란?</strong></p>\n<p>데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성을 말한다.\n영속성을 갖지 않는 데이터는 단지 메모리에서만 존재하기 때문에 프로그램을 종료하면 모두 잃어버리게 된다.</p>\n<p> </p>\n<p><strong>Object Persistence(영구적인 객체)</strong></p>\n<p>메모리 상의 데이터를 파일 시스템, 관계형 데이터베이스 혹은 객체 데이터베이스 등을 활용하여 영구적으로 저장하여 영속성을 부여한다. 데이터를 데이터베이스에 저장하는 방법은 아래와 같다.</p>\n<p><strong>1. JDBC (Java에서 사용)</strong>\n<strong>2. Spring JDBC (Ex. JdbcTemplate)</strong>\n<strong>3. Persistence Framework (Ex. Hibernate, MyBatis)</strong></p>\n<p> </p>\n<p><strong>Persistence Layer</strong></p>\n<p>프로그램의 아키텍처에서, 데이터에 영속성을 부여해주는 계층을 만한다.\nJDBC를 이용하여 직접 구현할 수 있지만 Persistence Framework를 이용한 개발이 많이 이루어진다.</p>\n<p> </p>\n<p><strong>Persistence Framework</strong></p>\n<p>JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발할 수 있으며 안정적인 구동을 보잡한다.\nSQL Mapper와 ORM으로 나눌 수 있습니다.</p>\n<p> </p>\n<p><strong>2. ORM이란?</strong></p>\n<p><img src=\"https://images.velog.io/images/quato/post/03b22e22-7c9a-4cdc-958c-a9c048f08dfe/image.png\" alt=\"\"></p>\n<p><strong>Object-Relational Mapping</strong></p>\n<p>객체 지향 프로그래밍은 클래스를 사용하고, 관계형 데이터베이스는 테이블을 사용한다. 그러므로 객체 모델과 관계형 모델 간에 불일치가 존재한다. ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결해준다.</p>\n<p>Persistant API라고도 부릅니다. ex) JPA, Hibernate</p>\n<p> </p>\n<p><strong>ORM의 장점</strong></p>\n<p>‣ 객체 지향적인 코드로 인해 더 직관적이고, 비즈니스 로직에 더 집중할 수 있게 도와준다.</p>\n<ul>\n<li>ORM을 이용하면 SQL 쿼리가 아닌 직관적인 코드로 데이터를 조작할 수 있어 개발자가 객체 지향 프로그래밍하는 데 집중할 수 있도록 도와즌다.</li>\n<li>선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다.</li>\n<li>각종 객체에 대한 코드를 별도록 작성하기 때문에 코드의 가독성을 올려준다.</li>\n<li>SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가힌다.</li>\n</ul>\n<p>‣ 재사용성 및 유지보수의 편리성이 증가한다.</p>\n<ul>\n<li>ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용할 수 있다.</li>\n<li>이로 인해 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.</li>\n<li>매핑정보가 명확하여 ERD를 보는 것에 대한 의존도를 낮출 수 있다.</li>\n</ul>\n<p>‣ DBMS에 대한 종속성이 줄어든다.</p>\n<ul>\n<li>대부분 ORM 솔루션은 DB에 종속적이지 않다.</li>\n<li>종속적이지 않다는 것은 구현 방법 뿐만 아니라 많은 솔루션에서 자료형 타입까지 유효하다.</li>\n<li>개발자는 Object에 집중함으로써 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.</li>\n<li>또한 자바에서 가공할 경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능해진다.</li>\n</ul>\n<p> </p>\n<p><strong>ORM의 단점</strong></p>\n<p>‣ 완벽한 ORM으로만 서비스를 구현하기가 어렵다.</p>\n<ul>\n<li>사용하기는 편하지만 설계는 매우 신중하게 해야한다.</li>\n<li>프로젝트의 복잡성이 커질 경우 난이도 또한 올라갈 수 있다.</li>\n<li>잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길수 있다.</li>\n</ul>\n<p>‣ 프로시저가 많은 시스템에서는 ORM의 객체 지향적인 장점을 활용하기 어렵다.</p>\n<ul>\n<li>이미 프로시저가 많은 시스템에서는 다시 객체로 바꿔야함, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.</li>\n</ul>\n<p> </p>\n<h2>📆   2021. 11. 18 (금)</h2>\n<h3><span>[Database] NoSQL</span></h3>\n<p> </p>\n<p><strong>NoSQL 데이터베이스란?</strong></p>\n<p>NoSQL 데이터베이스는 특정 데이터 모델에 대해 특정 목적에 맞추어 구축되는 데이터베이스로서 현대적인 애플리케이션 구축을 위한 유연한 스키마를 갖추고 있다. NoSQL 데이터베이스는 개발의 용이성, 기능성 및 확장성을 널리 인정받고 있다.</p>\n<p> </p>\n<p><strong>NoSQL(비관계형) 데이터베이스의 작동 방식</strong></p>\n<p>NoSQL 데이터베이스에서는 데이터의 액세스 및 관리를 위해 다양한 데이터 모델을 사용한다. 이러한 데이터베이스 유형은 큰 테이터 볼륨, 짧은 지연 시간과 유연한 데이터 모델이 필요한 애플리케이션에 최적화되었으며, 이는 다른 데이터베이스의 데이터 일관성 제약 일부를 완화함으로써 이루어진다.</p>\n<p>간단한 서적 데이터베이스를 위한 스키마 모델 구축 사례를 고려해 보자:</p>\n<ul>\n<li>관계형 데이터베이스에서, 서적 레코드는 흔히 숨겨져(또는 “정규화되어”) 별도의 테이블에 보관되고, 관계는 기본 및 외래 키 제약 조건으로 정의된다. 이 예시에서 서적 테이블에는 ISBN, 책 제목, 및 에디션 번호 열이 있으며, 저자 테이블에는 저자 ID 및 저자명 열이 있고, 마지막으로 저자-ISBN 테이블에는 저자 ID 및 ISBN 열이 있다. 관계형 모델은 중복성을 줄이도록 정규화되고 일반적으로 저장에 최적화된 데이터베이스에서 데이터베이스가 테이블 사이에서 참조 무결성을 실현할 수 있도록 고안되었다.</li>\n<li>NoSQL 데이터베이스에서, 서적 레코드는 보통 JSON 문서로 저장됩니다. 각각의 서적에 대해, 항목, ISBN, 책제목, 에디션 번호, 저자명, 및 저자 ID가 단일 문서 내에 속성으로 저장됩니다. 이 모델에서, 데이터는 직관적 개발과 수평 확장성에 최적화된다.</li>\n</ul>\n<p> </p>\n<p><strong>NoSQL 데이터베이스를 사용해야 하는 이유</strong></p>\n<p>NoSQL 데이터베이스는 탁월한 사용자 경험을 제공하기 위하여 유연성과 확장성을 비롯해 고성능의 매우 기능적인 데이터베이스를 필요로 하는 모바일, 웹이나 게이밍과 같은 다양한 현대적인 애플리케이션에 적합하다.</p>\n<ul>\n<li>유연성: NoSQL 데이터베이스는 일반적으로 유연한 스키마를 제공하여 보다 빠르고 반복적인 개발을 가능하게 해준다. 이같은 유연한 데이터 모델은 NoSQL 데이터베이스를 반정형 및 비정형 데이터에 이상적으로 만들어 준다.</li>\n<li>확장성: NoSQL 데이터베이스는 일반적으로 고가의 강력한 서버를 추가하는 대신 분산형 하드웨어 클러스터를 이용해 확장하도록 설계되었다. 일부 클라우드 제공자들은 완전관리형 서비스로서 이런 운영 작업을 보이지 않게 처리한다.</li>\n<li>고성능: NoSQL 데이터베이스는 특정 데이터 모델 및 액세스 패턴에 대해 최적화되어 관계형 데이터베이스를 통해 유사한 기능을 충족하려 할 때보다 뛰어난 성능을 얻게 해준다.</li>\n<li>고기능성: NoSQL 데이터베이스는 각 데이터 모델에 맞춰 특별히 구축된 뛰어난 기능의 API와 데이터 유형을 제공한다.</li>\n</ul>\n<p> </p>\n<p><strong>NoSQL 데이터베이스 유형</strong></p>\n<p><strong>1. 키 값</strong>:</p>\n<p>키 값 데이터베이스는 분할성이 커서 다른 유형의 데이터베이스로는 불가능한 범위까지 수평 확장을 가능하게 한다. 게이밍, 광고 기술 및 IoT와 같은 사용 사례에서 키 값 데이터 모델이 특별히 적합하다는 것을 보여준다.</p>\n<p><strong>2. 문서</strong></p>\n<p>애플리케이션 코드에서 데이터는 종종 객체 또는 JSON 유사 형식의 문서로 표시된다. 이 형식이 개발자에게 효율적이고 직관적인 데이터 모델이기 때문이다. 문서 데이터베이스를 사용하면 개발자들이 자신의 애플리케이션 코드에서 사용하는 것과 동일한 문서 모델 형식을 사용하여 데이터베이스에서 보다 손쉽게 데이터를 저장하고 쿼리할 수 있다. 문서 및 문서 데이터베이스의 유연하고 반구조화된 계층적 특성을 통해 개발자는 계속해서 애플리케이션의 요구를 발전시킬 수 있다. 문서 모델은 각 문서가 고유하고 시간에 따라 진화하는 콘텐츠 관리 시스템, 사용자 프로파일 및 카탈로그에서 사용할 수 있다.</p>\n<p><strong>3. 그래프</strong></p>\n<p>그래프 데이터베이스의 목적은 고도로 연결된 데이터세트를 사용하는 애플리케이션을 쉽게 구축하고 실행하는 것이다. 그래프 데이터베이스의 일반적인 사용 사례로는 소셜 네트워킹, 추천 엔진, 사기 감지 및 지식 그래프가 있다. 대중적인 그래프 데이터베이스에는 Neo4j와 Giraph가 있습니다.</p>\n<p> </p>\n<p><strong>SQL (관계형) vs. NoSQL(비관계형) 데이터베이스 비교</strong></p>\n<p>수십 년간, 애플리케이션 개발을 위해 가장 많이 사용된 데이터 모델은 Oracle, DB2, SQL Server, MySQL, PostgreSQL과 같은 관계형 데이터베이스에서 사용하는 관계형 데이터 모델이었다. 2000년대 중반에서 말에 이르러서야 다른 데이터 모델들이 채택되고 사용되는 현상이 눈에 띄기 시작했다. 이러한 새로운 데이터베이스와 데이터 모델 등급을 차별화하고 분류하기 위해 “NoSQL”이란 용어가 만들어졌다. 흔히 “NoSQL”이란 용어는 “비관계형”과 같은 의미로 사용된다.</p>\n<p>다양한 기능을 가진 여러 유형의 NoSQL 데이터베이스가 있지만, 다음 표에서는 SQL과 NoSQL 데이터베이스의 몇 가지 차이점에 대해 보여준다.</p>\n<p> </p>\n<p><strong>1. 관계형 데이터베이스</strong></p>\n<p><strong>최적의 워크로드</strong></p>\n<p>관계형 데이터베이스는 일관성이 뛰어난 온라인 트랜잭션 프로세싱(OLTP) 애플리케이션을 위해 설계되어 온라인 분석 프로세싱(OLAP)에 적합하다.</p>\n<p><strong>데이터 모델</strong></p>\n<p>관계형 모델은 데이터를 행과 열로 구성된 테이블로 정규화한다. 스키마는 테이블, 행, 열, 인덱스, 테이블 간 관계, 기타 데이터베이스 요소를 정확하게 규정한다. 데이터베이스는 테이블 사이의 관계에서 참조 무결성을 실현합한.</p>\n<p><strong>ACID 속성</strong></p>\n<p>관계형 데이터베이스는 원자가, 일관성, 격리성 및 지속성(ACID, atomicity, consistency, isolation, and durability)의 속성을 제공한다:</p>\n<ul>\n<li>원자가는 완벽하게 실행하거나 혹은 전혀 실행하지 않는 트랜잭션을 필요로 한다.</li>\n<li>일관성은 트랜잭션이 커밋되면 데이터가 데이터베이스 스키마를 준수하도록 요구한다.</li>\n<li>격리성은 동시에 일어나는 트랜잭션들이 각기 별도로 실행되어야 함을 의미한다.</li>\n<li>내구성은 예기치 못한 시스템 장애 또는 정전 시 마지막으로 알려진 상태로 복구하는 기능을 필요로 한다.</li>\n</ul>\n<p><strong>성능</strong></p>\n<p>성능은 일반적으로 디스크 하위 시스템에 따라 다릅니다. 최고 성능을 달성하기 위해서는 쿼리, 인덱스 및 테이블 구조를 자주 최적화해야 한다.</p>\n<p><strong>확장</strong></p>\n<p>관계형 데이터베이스는 일반적으로 하드웨어의 계산 성능을 높이거나 읽기 전용 워크로드의 복제물을 추가함으로써 확장된다.</p>\n<p><strong>API</strong></p>\n<p>데이터를 저장 및 검색하기 위한 요청은 SQL(구조화 질의 언어)을 준수하는 쿼리를 사용하여 전달된다. 쿼리는 관계형 데이터베이스에 의해 구문 분석되고 실행된다.</p>\n<p> </p>\n<p><strong>2. NoSQL 데이터베이스</strong></p>\n<p><strong>최적의 워크로드</strong></p>\n<p>NoSQL 데이터베이스는 낮은 지연 시간의 애플리케이션을 포함한 수많은 데이터 액세스 패턴에 맞도록 설계되었다. NoSQL 검색 데이터베이스는 반정형 데이터에서 분석을 위해 설계되었다</p>\n<p><strong>데이터 모델</strong></p>\n<p>NoSQL 데이터베이스는 키-값, 문서, 그래프 등 성능과 규모 확장에 최적화된 다양한 데이터 모델을 제공한다.</p>\n<p><strong>ACID 속성</strong></p>\n<p>NoSQL 데이터베이스는 흔히 수평으로 확장할 수 있는 보다 유연한 데이터 모델을 위해 관계형 데이터베이스의 일부 ACID 속성을 완화함으로써 조정한다. 이로써 NoSQL 데이터베이스는 단일 인스턴스의 한계를 넘어 수평으로 확장해야 하는 사용 사례에서 높은 처리량, 낮은 지연 시간을 위한 탁월한 선택이 된다.</p>\n<p><strong>성능</strong></p>\n<p>성능은 일반적으로 기본 하드웨어 클러스터 크기, 네트워크 지연 시간 및 호출 애플리케이션의 기능이다.</p>\n<p><strong>확장</strong></p>\n<p>NoSQL 데이터베이스는 일반적으로 거의 무제한적인 범위에서 일관된 성능을 제공하는 처리량 제고를 위해 분산형 아키텍처를 사용해 액세스 패턴이 확장 가능하기 때문에 분할성이 있다.</p>\n<p><strong>API</strong></p>\n<p>객체 기반 API를 통해 앱 개발자가 데이터 구조를 쉽게 저장 및 검색할 수 있다. 파티션 키를 사용하면 앱에서 키-값 페어, 열 세트 또는 일련의 앱 객체 및 속성을 포함하는 반정형 문서를 검색할 수 있다.</p>\n<p> </p>\n<p><strong>SQL과 NoSQL 용어 비교</strong></p>\n<p>다음 표에서는 엄선된 NoSQL 데이터베이스에서 사용하는 용어를 SQL 데이터베이스에서 사용하는 용어와 비교한다.</p>\n<p><img src=\"https://images.velog.io/images/quato/post/5358c156-0bc5-4cde-89c8-50a84ec1c657/image.png\" alt=\"\"></p>","timeToRead":10,"frontmatter":{"title":"CodeStates IM [week 12]","summary":"CodeState Pre IM 12주차 기록입니다.","date":"15 November, 2021","category":"Codestates","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAEGBwn/xAAWAQEBAQAAAAAAAAAAAAAAAAACAwb/2gAMAwEAAhADEAAAAdhYTZq2hBk1/8QAGBABAQADAAAAAAAAAAAAAAAABAMFBiD/2gAIAQEAAQUCci5jHyWx1Rx//8QAHBEBAAEEAwAAAAAAAAAAAAAAASECETFxEBJC/9oACAEDAQE/AUX3UYg6TbdKzhs6szx//8QAGxEAAgIDAQAAAAAAAAAAAAAAAQIDIQAREiL/2gAIAQIBAT8BV1CFTDG5JqRjL2tEaHMipq+rQ+gN1Rz/xAAhEAACAgEDBQEAAAAAAAAAAAACAwEEEgURIgAGFBUgI//aAAgBAQAGPwJjq1F+ouGOFSuyspjJxKY523V0iOUCJfply3ES2nrTAb24Nau9aPaOZqSDKi01ybhrrTLPJBB7KyKQk5nKIx+f/8QAFxABAQEBAAAAAAAAAAAAAAAAAREgUf/aAAgBAQABPyFMTOwEaIWIYALXwmCyRtpZQuf/2gAMAwEAAgADAAAAEBsP/8QAGBEBAQEBAQAAAAAAAAAAAAAAARExECH/2gAIAQMBAT8QcECKRilRZ5wPNcH/xAAXEQEBAQEAAAAAAAAAAAAAAAABERAh/9oACAECAQE/EFWWQFCi4GFvQby//8QAGxABAQACAwEAAAAAAAAAAAAAAREQUQAxkUH/2gAIAQEAAT8QL2S311OpjrH4MVdtjNj0zgoSwpGFNP0xDR5rrzH/2Q=="},"images":{"fallback":{"src":"/static/5ae71771cc28d8142710f1d07c2f1e79/9d1bb/codestate-software-engineer.jpg","srcSet":"/static/5ae71771cc28d8142710f1d07c2f1e79/35c22/codestate-software-engineer.jpg 183w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/0837d/codestate-software-engineer.jpg 365w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/9d1bb/codestate-software-engineer.jpg 730w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/0a556/codestate-software-engineer.jpg 1460w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/static/5ae71771cc28d8142710f1d07c2f1e79/98c3d/codestate-software-engineer.webp 183w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/da319/codestate-software-engineer.webp 365w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/e195b/codestate-software-engineer.webp 730w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/b523f/codestate-software-engineer.webp 1460w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":411}},"publicURL":"/static/5ae71771cc28d8142710f1d07c2f1e79/codestate-software-engineer.jpeg"}}}}]}},"pageContext":{"slug":"/CodeStates/2021-11-15-CodeStates IM [week 7]/"}},
    "staticQueryHashes": ["2368566813","3026479947","3227158195","413061808"]}