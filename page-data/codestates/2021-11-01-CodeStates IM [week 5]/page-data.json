{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/CodeStates/2021-11-01-CodeStates IM [week 5]/",
    "result": {"data":{"posts":{"edges":[{"node":{"id":"b6ce60d1-2ddf-523e-b735-2a3ec1294f1b","html":"<h2>📆   2021. 11. 01 (월)</h2>\n<h3><span>[React] 상태 관리 (Hook)</span></h3>\n<p> </p>\n<p>Hooks는 리액트 v16.8 에 새로 도입된 기능으로서, 함수형 컴포넌트에서도 상태 관리를 할 수 있는 useState, 그리고 렌더링 직후 작업을 설정하는 useEffect 등의 기능등을 제공하여 기존의 함수형 컴포넌트에서 할 수 없었던 다양한 작업을 할 수 있게 해준다.</p>\n<p> </p>\n<p><strong>1. useState</strong></p>\n<p>useState는 가장 기본적인 Hook 으로서, 함수형 컴포넌트에서도 가변적인 상태를 지니고 있을 수 있게 해준다. 만약에 함수형 컴포넌트에서 상태를 관리해야 되는 일이 발생한다면 이 Hook을 사용하시면 된다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">import React, { useState } from &#39;react&#39;;\n\nconst Counter = () =&gt; {\n  const [value, setValue] = useState(0);\n  return (\n    &lt;div&gt;\n      &lt;p&gt;\n        현재 카운터 값은 &lt;b&gt;{value}&lt;/b&gt; 입니다.\n      &lt;/p&gt;\n      &lt;button onClick={() =&gt; setValue(value + 1)}&gt;+1&lt;/button&gt;\n      &lt;button onClick={() =&gt; setValue(value - 1)}&gt;-1&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};</code>\n        </deckgo-highlight-code>\n<p>useState를 사용할 땐 상단에서 import 구문을 통하여 불러오며 배열 비구조화 할당을 사용한 문법으로 사용된다. 배열의 첫번째 원소는 상태 값이고, 두번째 원소는 상태를 설정하는 함수입니다. 이 함수에 파라미터를 넣어서 호출하게 되면 전달받은 파라미터로 값이 바뀌게 되고 컴포넌트는 정상적으로 리렌더링 됩니다.</p>\n<p> </p>\n<p><strong>2. useEffect</strong></p>\n<p>useEffect는 리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정 할 수 있는 Hook 이다. 클래스형 컴포넌트의 componentDidMount 와 componentDidUpdate를 합친 형태와 유사하다.</p>\n<p>useEffect을 사용하기 위해서는 useState와 마찬가지로 상단에서 import를 이용하여 불러온다.</p>\n<p> </p>\n<p><strong>2.1 마운트 될 때만 실행하고 싶을 때</strong></p>\n<p>만약 useEffect 에서 설정한 함수가 컴포넌트가 화면에 가장 처음 렌더링 될 때만 실행되고 업데이트 할 경우에는 실행 할 필요가 없는 경우엔 함수의 두번째 파라미터로 비어있는 배열을 넣어주시면 됩니다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">  useEffect(() =&gt; {\n    console.log(&#39;마운트 될 때만 실행됩니다.&#39;);\n  }, []);</code>\n        </deckgo-highlight-code>\n<p> </p>\n<p><strong>2.2 특정 값이 업데이트 될 때만 실행하고 싶을 때</strong></p>\n<p>useEffect의 두번째 파라미터로 전달되는 배열 안에 검사하고 싶은 값을 넣어주시면 된다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">useEffect(() =&gt; {\n    console.log(name);\n  }, [name]);</code>\n        </deckgo-highlight-code>\n<p>배열 안에는 useState 를 통해 관리하고 있는 상태를 넣어줘도 되고, props 로 전달받은 값을 넣어주어도 된다.</p>\n<p> </p>\n<p><strong>2.3 뒷정리 하기</strong></p>\n<p>useEffect는 기본적으로 렌더링 되고난 직후마다 실행되며, 두번째 파라미터 배열에 무엇을 넣느냐에 따라 실행되는 조건이 달라진다.</p>\n<p>만약 컴포넌트가 언마운트되기 전이나, 업데이트 되기 직전에 어떠한 작업을 수행하고 싶다면 useEffect 에서 뒷정리(cleanup) 함수를 반환해주어야 한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">  useEffect(() =&gt; {\n    console.log(&#39;effect&#39;);\n    console.log(name);\n    return () =&gt; {\n      console.log(&#39;cleanup&#39;);\n      console.log(name);\n    };\n  });</code>\n        </deckgo-highlight-code>\n<p> </p>\n<h2>📆   2021. 11. 02 (화)</h2>\n<h3><span>[React] 상태 관리 (Redux)</span></h3>\n<p> </p>\n<p>Redux는 거의 최초로 React 기반의 상태 관리 라이브러리이다. Redux는 Store라고 하는 Javascript 객체를 제공하며, 한 번 설정으로 어플리케이션의 모든 상태를 포함하고, 필요할 때 업데이트 한다. 다음은 Redux의 작동 방식을 도식화 한 그림이다.</p>\n<p><img src=\"https://images.velog.io/images/quato/post/46444273-57cd-4128-a96f-f63960b08fc7/image.png\" alt=\"\"></p>\n<p>Redux가 React와 자주 함께 사용되는 이유는 Redux는 사용자의 액션에 반응(특히 UI에서)하며 상태 업데이트를 처리하기 때문아다. 또한 Redux는 모든 프레임워크에서 독립 실행형 상태 관리 툴로 사용할 수 있다.</p>\n<p> </p>\n<p><strong>언제 Redux를 사용해야 할까요?</strong></p>\n<p>Redux를 사용하면 앱의 상태를 한 곳에서 관리하고 앱의 변경사항을 보다 예측 가능하고 추적 가능한 상태로 유지할 수 있다. 앱에서 발생하는 변경 사항을 보다 쉽게 파악할 수 있다. 하지만 불행하게도 이 모든 이점에는 특정한 제약과 단점이 따른다.</p>\n<p>종종 어떤 개발자들은 Redux를 사용하는 것이 보일러플레이트 코드를 크게 만든다고 생각하며, 불필요하게 어플리케이션이 커진다고 생각한다. 그러나 이는 어플리케이션 아키텍처를 어떻게 구성하느냐에 달려 있다.</p>\n<p>Redux를 사용해야 하는 지 알 수 있는 가장 쉬운 방법 중 하나는 로컬에서 상태를 관리하는 것이 지저분해 보이기 시작할 때이다. 어플리케이션이 커짐에 따라 컴포넌트 간 상태 공유는 힘들어진다. 그러면 프로세스를 번거롭지 않게 만드는 방법을 찾기 시작할 것이다.</p>\n<p> </p>\n<p><strong>왜 Redux를 사용해야 할까요?</strong></p>\n<p>Redux with React를 사용하면 상태를 끌어올리는 번거로움이 없어져 어떤 액션이 변경되었는지 쉽게 추적할 수 있으므로 앱이 간편해지고 유지관리가 쉬워진다. 리액트에 Redux를 사용할 경우 얻을 수 있는 몇 가지 장단점은 아래와 같다.</p>\n<p> </p>\n<p><strong>1. 커뮤니티 지원</strong></p>\n<p>React 와 Redux의 공식 바인딩 라이브러리인 React-Redux는 대규모 사용자 커뮤니티가 구축되어 있다. 이를 통해 도움을 요청하고, 모범 사례에 대해 배우고, React-Redux를 기반으로 하는 라이브러리를 사용하고, 다양한 어플리케이션에서 지식을 재사용할 수 있다. Github에서 가장 별을 많이 받은 리액트 상태 관리 라이브러리다.</p>\n<p> </p>\n<p><strong>2. 성능 향상</strong></p>\n<p>React Redux는 성능 최적화를 보장하여 필요할 때만 연결된 컴포넌트를 다시 렌더링 한다. 따라서 앱의 상태를 글로벌하게 유지하는 것은 문제가 되지 않는다.</p>\n<p> </p>\n<p><strong>3.Redux를 통한 상태 예측</strong></p>\n<p>Redux에서는 상태를 항상 예측 할 수 있다. 동일한 상태와 액션이 리듀서로 전달되는 경우, 리듀서는 순수 함수이기 때문에 동일한 결과를 얻는다. 상태 또한 불변이며 절대 변하지 않는다. 이것은 무한한 실행 취소와 재실행과 같은 힘든 작업을 구현할 수 있게 해준다. 또한 시간 여행을 구현할 수 있다. 즉, 이전 상태를 왔다 갔다 하며 실시간으로 결과를 확인 할 수 있다.</p>\n<p> </p>\n<p><strong>4. 로컬 스토리지를 통한 상태 지속성</strong></p>\n<p>앱의 상태 중 일부를 로컬 스토리지에 유지하고 새로고침 후 복원할 수 있다. 이를 통해 카트 데이터와 같은 것을 로컬 스토리지에 저장할 수 있다.</p>\n<p> </p>\n<p><strong>5. 서버 사이드 렌더링</strong></p>\n<p>서버 사이드 렌더링을 위해 Redux를 사용할 수 있다. 서버 요청에 대한 응답과 함께 앱의 상태를 서버로 전송하여 앱의 초기 렌더링을 처리 할 수 있다.</p>\n<p> </p>\n<p><strong>6. 유지보수성</strong></p>\n<p>Redux는 코드를 설계하는 방법에 대해 엄격하기 때문에 함께 협업을 할 때 어플리케이션의 구조를 쉽게 이해할 수 있다. 이것을 일반적으로 유지보수를 더 쉽게 해준다. 또한 컴포넌트 트리에서 비즈니스 로직을 분리할 수 있다. 대규모 어플리케이션의 경우 어플리케이션을 보다 예측 가능하게 하고 유지 관리 하는 것이 중요하다.</p>\n<p> </p>\n<p><strong>7. 쉬운 디버깅</strong></p>\n<p>Redux를 사용하면 어플리케이션을 쉽게 디버깅할 수 있다. 액션과 상태를 로깅하면 코딩 오류, 네트워크 오류 및 운영 중에 발생할 수 있는 기타 버그 유형을 쉽게 이해할 수 있다.</p>\n<p>로깅 외에도 time-travel 액션, 페이지 새로 고침 시 작업 지속 등을 지원하는 탁월한 개발자도구가 있다. 어플리케이션 규모가 커질 수록, 디버깅은 기능을 개발하는 것보다 더 많은 시간이 소요된다.</p>\n<p>Redux의 이점도 있지만 모든 어플리케이션에 Redux를 추가할 필요는 없다. Redux 없이도 어플리케이션을 제대로 동작할 수 있다.</p>\n<p> </p>\n<h2>📆   2021. 11. 03 (수)</h2>\n<h3><span>[HA] 대비 복습</span></h3>\n<p> </p>\n<p>내일부터 진행되는 두 번째 HA를 대비하기 위해 Section 2에서 배웠던 내용을 복습했다. 지금까지 배운 내용은 아래와 같다.</p>\n<ul>\n<li>JS 객체 지향</li>\n<li>재귀함수</li>\n<li>자료구조</li>\n<li>JS 비동기</li>\n<li>REST API</li>\n<li>React State 끌어올리기, Effect Hook</li>\n<li>React 컴포넌트 디자인</li>\n<li>Redux</li>\n</ul>\n<p>한달 정도에 기간동안 많이도 배웠다. Section 2는 Section 1보다 체감상 더 빠르게 지나갔다. 내용이 더 어려워 쉴 시간이 없어서 그런 것 같다. 다행인 것은 지난번보다 React에 대한 이해도가 높아져서 HA에 대한 부담감이 줄어들었다.</p>\n<p>Section 2에서 가장 힘들었던 부분은 자료구조 부분이었다. 다른 동기들도 유독 어려워했는데 처음 접하는 개념들이 쏟아졌기 때문이기도 했고 제대로 된 이해도 전에 알고리즘으로 구현해야했기에 멘탈을 부여잡기가 쉽지 않았다.</p>\n<p>그래도 어찌저찌 시간이 흐르고 여러번 복습을 진행하다보니 처음 코드를 작성할때보다 수월해지는 것을 실시간으로 느낄 수 있었다. 역시 복습이 최고인 것 같다.</p>\n<p>이번 HA를 통과하게 되면 프로젝트 전 마지막 학습단계인 Section 3가 기다리고 있다. Section 2에서는 Front-end 요소가 많이 포함되어있던 것에 비해 Back-end 요소의 비중이 높아 진다. 내심 마음 속으로는 Back-end 쪽이 적성에 더 맞는 것 같아 학습에 대한 기대가 더 높은 것 같다.</p>\n<p>이제 코스 과정도 절반 정도 지나왔다. 짧은 시간 동안 많은 내용은 머리 속에 들이 부었는데 다행이 과부하는 걸리지 않았지만 개념이 완벽히 자리잡지는 못했다. 앞으로의 기간 동안 후회가 남지 않도록 최선을 다해야 겠다.</p>\n<p> </p>\n<h2>📆   2021. 11. 04 (목)</h2>\n<h3><span>[HA] day 1</span></h3>\n<p> </p>\n<p>이틀 동안 진행되는 HA의 첫 째날이다. 오전에는 배포에 관하여 학습한 후 오후 2시부터 진행되었다. 총 3문제의 알고리즘 문제가 출제되었다. HA 전에 재귀와 자료구조 문제가 나올거라고 알려주셔서 중점적으로 공부했는데 재귀 2문제, 자료구조 1문제가 출제되었다.</p>\n<p>첫 문제는 클로저 함수를 재귀 함수로 사용하여 n회 실행 시 n번째 피보나치 수열이 리턴되는 알고리즘을 구현했다. 피보나치 함수를 구현하는 것은 코플릿 문제에서 풀어보았기 때문에 n회 실행시 다음 피보나치 수열이 리턴되는 코드만 작성하면 되었다. 풀이법은 count를 변수로 선언하고 호출할 때마다 1씩 증가시킨 후 클로저 함수를 호출하는 방법을 사용하였다.</p>\n<p>두 번째 문제는 객체를 요소로 같는 배열과 특정 id값을 받은 후 특정 id값을 갖는 객체를 리턴하는 알고리즘을 구현하는 것이다. 이 문제 또한 코플릿 문제 중 비슷한 문제가 있어 어렵지 않게 코드를 작성할 수 있었다. 하지만 마지막 1문제가 해결되지 않았는데 초기값을 설정 후 다시 작성하니 모든 문제가 해결되었다. 왜 그런건지는 좀 더 고민해봐야겠다.</p>\n<p>세 번째 문제는 간선들의 목록들을 받아 2차원 배열의 무향 그래프 매트릭스를 출력하는 함수를 작성하는 것이다. 코플릿 문제 중 2차원 배열의 그래프 매트릭스를 출력하는 함수를 참고하여 작성했으며 가장 고난이도의 문제였다. 시간이 오래걸렸지만 모두 해결할 수 있었다.</p>\n<p>Section 1때의 HA와 마찬가지로 과제형보다는 코플릿형이 자신감이 있어 편한 마음으로 풀이를 할 수 있었다. 내일은 리액트를 이용한 과제형 문제가 출제된다. 저번 HA에 비해 React에 비중을 두고 공부한 만큼 좋은 결과가 있었으면 좋겠다.\n </p>\n<h2>📆   2021. 11. 05 (금)</h2>\n<h3><span>[HA] day 2</span></h3>\n<p> </p>\n<p>HA 두 번째 날이다. 어제와 달리 오전 9시에 시작해서 오후 6시까지 시험을 치른다. Section 1에서는 과제형이 시간이 짧아 조급한 마음으로 풀었는데 오늘은 여유롭게 풀이를 할 수 있었다. 그런데 과제형은 시간이 많다고 꼭 더 많이 푸는 건 아닌것 같긴해…😅</p>\n<p>과제형으로 풀어 볼 문제는 리액트를 이용하여 영화 순위정보를 보여주는 웹사이트를 구현해보는 것이다. client 파트와 server 파트가 나눠져 있고 서로 관계는 없다. 각각 npm install을 해준 후 server 파트부터 풀이를 시작했다. client 파트에 비해 문제 수와 난이도는 높지 않았다. 아무래도 Section 2에서 back-end 비중이 적어 난이도를 올리지 않은 것 같다. get을 이용한 요청에 관한 문제만 출제되었고 params을 이용하여 특정 매개 변수를 요청하는게 그나마 고난이도의 문제였다.</p>\n<p>client 파트는 시간이 오래걸렸다. 작성해야할 부분도 많이 있었고 오류 처리가 되지 않아 구현 후에도 한참 코드를 쳐다봐야했다. 지금까지 배웠던 내용이 골고루 들어가 있었다. API fetch를 통해 endpoint로 부터 정보를 받아오고 useState와 useEffect를 통해 상태를 관리했다. 나머지 기능들은 props를 통해 인자를 전달하여 fetch로 받은 정보들을 다른 컴포넌트에서 사용가능하도록 해주었다.</p>\n<p>Section 1에서는 과제형 문제에서 제대로 구현하지도 못하고 제출해서 마음이 좋지 않았는데 이번에는 client와 server 모두 제대로 구현할 수 있어서 다행이었고, 그래도 공부를 했구나라고 느낄 수 있어서 뿌듯했다.</p>\n<p>별다른 사항이 없으면 HA는 통과할 것으로 예상한다. Section 3는 Back-end에 관하여 진행되는 만큼 주말을 이용하여 서버와 관련된 학습을 진행해야 겠다.</p>\n<p> </p>\n<p><strong>하루 후…</strong></p>\n<p><img src=\"https://images.velog.io/images/quato/post/0cc4d323-c6b7-4958-a696-aab38d1b4a7d/image.png\" alt=\"\"></p>\n<p>통과~!!😁</p>","timeToRead":7,"frontmatter":{"title":"CodeStates IM [week 10]","summary":"CodeState Pre IM 10주차 기록입니다.","date":"01 November, 2021","category":"Codestates","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAEGBwn/xAAWAQEBAQAAAAAAAAAAAAAAAAACAwb/2gAMAwEAAhADEAAAAdhYTZq2hBk1/8QAGBABAQADAAAAAAAAAAAAAAAABAMFBiD/2gAIAQEAAQUCci5jHyWx1Rx//8QAHBEBAAEEAwAAAAAAAAAAAAAAASECETFxEBJC/9oACAEDAQE/AUX3UYg6TbdKzhs6szx//8QAGxEAAgIDAQAAAAAAAAAAAAAAAQIDIQAREiL/2gAIAQIBAT8BV1CFTDG5JqRjL2tEaHMipq+rQ+gN1Rz/xAAhEAACAgEDBQEAAAAAAAAAAAACAwEEEgURIgAGFBUgI//aAAgBAQAGPwJjq1F+ouGOFSuyspjJxKY523V0iOUCJfply3ES2nrTAb24Nau9aPaOZqSDKi01ybhrrTLPJBB7KyKQk5nKIx+f/8QAFxABAQEBAAAAAAAAAAAAAAAAAREgUf/aAAgBAQABPyFMTOwEaIWIYALXwmCyRtpZQuf/2gAMAwEAAgADAAAAEBsP/8QAGBEBAQEBAQAAAAAAAAAAAAAAARExECH/2gAIAQMBAT8QcECKRilRZ5wPNcH/xAAXEQEBAQEAAAAAAAAAAAAAAAABERAh/9oACAECAQE/EFWWQFCi4GFvQby//8QAGxABAQACAwEAAAAAAAAAAAAAAREQUQAxkUH/2gAIAQEAAT8QL2S311OpjrH4MVdtjNj0zgoSwpGFNP0xDR5rrzH/2Q=="},"images":{"fallback":{"src":"/static/5ae71771cc28d8142710f1d07c2f1e79/9d1bb/codestate-software-engineer.jpg","srcSet":"/static/5ae71771cc28d8142710f1d07c2f1e79/35c22/codestate-software-engineer.jpg 183w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/0837d/codestate-software-engineer.jpg 365w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/9d1bb/codestate-software-engineer.jpg 730w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/0a556/codestate-software-engineer.jpg 1460w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/static/5ae71771cc28d8142710f1d07c2f1e79/98c3d/codestate-software-engineer.webp 183w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/da319/codestate-software-engineer.webp 365w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/e195b/codestate-software-engineer.webp 730w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/b523f/codestate-software-engineer.webp 1460w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":411}},"publicURL":"/static/5ae71771cc28d8142710f1d07c2f1e79/codestate-software-engineer.jpeg"}}}}]}},"pageContext":{"slug":"/CodeStates/2021-11-01-CodeStates IM [week 5]/"}},
    "staticQueryHashes": ["2368566813","3026479947","3227158195","413061808"]}