{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/CodeStates/2021-11-22-CodeStates IM [week 13]/",
    "result": {"data":{"posts":{"edges":[{"node":{"id":"cc4b671f-be4c-5966-a260-3aee65a65b83","html":"<h2>📆   2021. 11. 22 (월)</h2>\n<h3><span>[인증/보안] https, 쿠키, 세션</span></h3>\n<p> </p>\n<p><strong>HTTP?</strong></p>\n<p>HTTP는 Hyper Text Transfer Protocol의 줄임말으로써 서버와 클라이언트간에 데이터를 주고 받는 프로토콜이다. HTTP는 텍스트, 이미지,영상, JSON 등등 거의 모든 형태의 데이터를 전송할수 있다.\n세상에 등장한지 벌써 30년이나 된 HTTP는 1997년 만들어진 HTTP/1.1가 가장 보편화 되어있으며, 현재는 HTTP/2를 거쳐 HTTP/3까지 개발된 상태입니다. TCP를 개선해서 만들어진 UDP가 HTTP/3 기술에 사용된다.</p>\n<p> </p>\n<p><strong>HTTP는 보안적으로 안전한가?</strong></p>\n<p>HTTP 통신은 클라이언트와 서버간의 통신에 있어서 별다른 보안 조치가 없기때문에 만약 누군가 네트워크 신호를 가로챈다면 HTTP의 내용은 그대로 외부에 노출된다.\n중요 정보가 없는 소규모의 프로젝트라면 문제가 되지 않겠지만 고객의 개인정보나 비밀을 취급하는 대규모 서비스라면 큰 보안적 허점이 될 것이다.\n이런 문제를 해결하기 위해 등장한 것이 HTTPS이다.</p>\n<p> </p>\n<p><strong>🔐 HTTPS?</strong></p>\n<p><img src=\"https://images.velog.io/images/quato/post/fb61494b-feb2-47d0-acc8-44c506327a9b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-11-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.37.40.png\" alt=\"\"></p>\n<p>요즘은 거의 모든 사이트의 주소창에서 자물쇠 표시를 볼 수 있습니다. HTTPS가 적용되었다는걸 알려주는게 바로 저 자물쇠 다. HTTPS가 옛날부터 보편화되어있지는 않았습니다. 처음에는 전자상거래 등 고객의 중요 정보를 다루는 사이트 위주로 사용되었다.\n그러다가 2014년 구글에서는 HTTP를 HTTPS로 변환하라고 권고하기 시작한다. 구글은 HTTPS를 적용하는 사이트들에게 SEO(검색 엔진 최적화)에 있어서 가산점을 주겠다고했다. 사용자 정보의 안전성도 보장받고, 사용자들의 웹사이트 유입도 늘릴수 있으니 HTTPS로 변환할 이유는 충분했다.</p>\n<p> </p>\n<p><strong>HTTPS는 어떤 방식으로 보안 이슈를 해결하는가?</strong></p>\n<p>기존의 HTTP 프로토콜은 전송계층의 TCP위에서 동작한다. 여기서 SSL(Secure Sockets Layer)이라는 보안계층이 전송계층 위에 올라간다. HTTPS는 SSL 위에 HTTP를 얹어서 보안이 보장된 통신을 하는 프로토콜이다. 이 통신 방식을 SSL 암호화 통신 이라고도 한다. SSL 암호화 통신은 공개키 암호화 방식이라는 알고리즘을 통해 구현된다.</p>\n<p> </p>\n<p><strong>공개키 암호화 방식이란?</strong></p>\n<p>공개키 암호화 방식에는 공개키와 개인키 두 종류의 키가 존재한다.\n한쪽 키로 데이터를 암호화 했다면 오직 다른쪽 키로만 복호화를 할 수 있다. 개인키는 보통 서버를 운영하는 회사가 가지고 공개키는 CA(Certificate Authority)라는 인증받은 기업들에서 관리한다.</p>\n<p> </p>\n<p><strong>클라이언트와 서버간의 요청과 응답 과정</strong></p>\n<p>CA는 서버 운영 기업이 넘겨준 공개키를 인증서 발급자, CA의 이름 등과 함께 묶어서 CA가 가지고 있는 개인키로 암호화해서 SSL인증서로 발급해준다.\n차후에 클라이언트에서 요청을 하면 서버는 클라이언트에게 SSL 인증서를 보낸다. 브라우저(클라이언트)는 대표적인 CA들의 리스트와 그들의 공개키를 보유하고 있다. 만약 인증서에 적힌 CA의 이름과 브라우저가 소유하고 있는 CA 이름이 같다면 CA의 공개키로 SSL 인증서를 복호화 한다.\n이제 SSL내부에 들어있던 서버의 공개키를 가지고 요청을 암호화해서 서버에게 보낸다. 서버측은 가지고 있는 개인키로 요청을 복호화하여 해석하고 응답은 다시 암호화 해서 보낸다. 이 과정을 통해 보안성이 강한 통신을 할 수 있게 된다.</p>\n<hr>\n<p> </p>\n<p><strong>🔐 Cookie</strong></p>\n<p>UNIX OS에서 프로그램 사이에 전송되는 작은 데이터 패킷을 “Magic Cookie”라고 불렀는데,\n클라이언트에서 서버로 전송되는 작은 데이터라는 개념이 비슷하여 여기서 가져온 것이라 한다.</p>\n<p>매직 쿠키라는 용어는 쿠키를 열면 메세지가 나오는 포춘 쿠키에서 파생된 용어라고 한다.</p>\n<p> </p>\n<p><strong>쿠키의 동작방식</strong></p>\n<p>HTTP 쿠키는 서버가 클라이언트에게 준 정보를 브라우저에 저장하고, 클라이언트가 요청을 보낼 때 HTTP 헤더에 정보를 담아서 서버에 전달한다.</p>\n<p><img src=\"https://images.velog.io/images/quato/post/fae03b84-9fd4-40c4-855c-fd8e34781f18/image.png\" alt=\"\"></p>\n<p> </p>\n<p><strong>1. 클라이언트의 첫 HTTP Request</strong></p>\n<p>클라이언트가 웹 사이트를 첫 방문하면 서버는 해당 클라이언트를 식별하기 위한 Key-Value 객체를 만든다.\n(자바스크립트 객체로 표현했지만, 실제로 이렇게 생겼다는 것은 아니다. 실제로는 String이다.)</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">{\n  Name: &quot;status&quot;,\n  Value: &quot;lawyer&quot;,\n  Domain: &quot;www.lawandgood.com&quot;,\n  Path: &quot;/&quot;,\n  Expires: &quot;2021-09-30T23:59:59.000Z&quot;,\n  .\n  .\n}</code>\n        </deckgo-highlight-code>\n<p> </p>\n<p><strong>2. 서버의 HTTP Response</strong></p>\n<p>HTTP 헤더의 Set-Cookie 항목에 쿠키를 담아서 전달한다. 클라이언트는 Set-Cookie 헤더에 있는 쿠키를 브라우저에 저장한다.</p>\n<p>꼭 Set-Cookie 헤더를 통해 쿠키를 세팅할 수 있는 것은 아니다. 서버에서 렌더링하는 HTML에 정보를 전달하고 script 태그 내에서 쿠키를 세팅할 수도 있고, 사용자가 어떤 버튼을 눌렀을 때 자바스크립트를 통해 쿠키를 서버 개입 없이 세팅해놓을 수도 있다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">&lt;script&gt;\n  setCookie({\n    name: &#39;status&#39;,\n    value: &#39;{{ user.status }}&#39;,\n    expires: new Date(&#39;2021-09-30 23:59:59&#39;),\n    .\n    .\n  })\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<p>쿠키의 저장위치는 브라우저가 어떻게 쿠키 스토리지를 구현했느냐에 따라 다르다.</p>\n<p>크롬의 경우, 데이터를 SQLite에 저장하며 쿠키는 Cookies라는 항목에 쿠키를 습득한 사이트 별로 저장된다.</p>\n<p> </p>\n<p><strong>3. 클라이언트의 HTTP Request + Cookie</strong></p>\n<p>클라이언트의 첫 요청 이후, 다음 요청부터는 쿠키가 HTTP 헤더에 포함된다.</p>\n<p>브라우저가 가지고 있는 쿠키의 개수는 몇백개가 되는데, 모든 사이트를 방문하거나 API 요청을 보낼 때마다 몇백개의 쿠키를 HTTP 헤더에 담아서 보내지는 않는다.</p>\n<p>쿠키에는 Domain과 Path라는 속성이 있다.</p>\n<p><code>Domain</code> : HTTP 요청을 보낼 주소의 도메인이 Domain 속성값과 같은 경우에만 쿠키를 보낸다.<br>\n<code>Path</code> : HTTP 요청을 보낼 주소의 URL 경로가 Path 속성값과 같은 경우에만 쿠키를 보낸다.</p>\n<p>이렇게 쿠키를 서버로 보내서, 서버가 클라이언트를 식별할 수 있도록 한다.</p>\n<p> </p>\n<p><strong>HTTP Status Management Mechanism</strong></p>\n<p>쿠키의 기본 발상은 브라우저가 서버의 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하는 것이다.</p>\n<p>저장되는 서버 정보가 쿠키이고, 브라우저는 쿠키를 저장할 책임이 있다. 이러한 시스템을 “클라이언트 측 상태”, “HTTP 상태 관리 체계” 라고 한다.</p>\n<p> </p>\n<p><strong>쿠키의 종류</strong></p>\n<p>쿠키는 2종류가 있고, 둘의 차이점은 파기 시점뿐이다.</p>\n<p> </p>\n<p><strong>1. 세션쿠키</strong></p>\n<p>만료일을 설정하지 않기 때문에 브라우저를 종료하면 파기된다. (만료일은 Expires, Max-Age 로 설정한다.)</p>\n<p>사용자가 사이트를 탐색할 때 선호 사항, 임시 설정 등을 저장하는 쿠키</p>\n<ul>\n<li>최근 본 상품</li>\n<li>최근 검색어</li>\n</ul>\n<p> </p>\n<p><strong>2. 지속쿠키</strong></p>\n<p>디스크에 저장되어서 만료일까지는 브라우저를 끄거나 재부팅하여도 남아있는다.</p>\n<p>다음 방문에도 영향을 주는 설정 정보나 로그인 정보 등을 유지할 때 사용하는 쿠키</p>\n<ul>\n<li>일주일간 팝업 보지 않기</li>\n<li>로그인 유지</li>\n</ul>\n<p> </p>\n<p><strong>쿠키 제약조건</strong></p>\n<ul>\n<li>브라우저는 총 300개의 쿠키를 저장할 수 있다.</li>\n<li>하나의 도메인당 20개의 쿠키를 가질 수 있다. 초과되면 가장 적게 사용된 것부터 삭제한다.</li>\n<li>하나의 쿠키는 4KB까지 용량을 차지할 수 있다.</li>\n</ul>\n<p> </p>\n<p><strong>쿠키의 한계</strong></p>\n<ul>\n<li>민감한 정보를 그대로 HTTP 통신에 노출하는 경우 탈취당할 수 있다. 아이디와 패스워드를 쿠키에 넣어서 모든 요청마다 인증 정보를 포함하게 할 수 있는데, 통신 과정에서 패킷을 가로채가면 패스워드가 유출될 수 있다.</li>\n<li>쿠키의 보안 취약점을 보완하기 위해 “세션”이 등장한다.</li>\n</ul>\n<hr>\n<p> </p>\n<p><strong>🔐 Session</strong></p>\n<p><strong>세션 동작방식</strong></p>\n<p>쿠키가 탈취당할 수 있다는 것을 인지하여, 민감한 정보는 서버에만 저장하고 쿠키에는 서버에 저장된 정보를 찾을 수 있는 키만 전달하는 방식.</p>\n<p>쿠키를 사용하는 것에는 변함이 없고, 쿠키 값으로 어떤 것을 주느냐가 다르다.</p>\n<p> </p>\n<p><strong>1. 클라이언트의 첫 HTTP Request와 세션 생성</strong></p>\n<p>쿠키의 동작방식과 같이 클라이언트가 첫 요청을 보내면 서버는 이 클라이언트를 식별하기 위한 객체를 만든다.</p>\n<p>쿠키에서는 이 객체를 바로 HTTP 헤더에 담아서 보내지만, 세션에서는 이를 서버에 저장한다. 데이터베이스에 저장할 수도 있고, 서버의 파일 시스템에 저장할 수도 있다. 이렇게 세션이 저장되는 공간을 세션 스토리지라고 한다.</p>\n<p> </p>\n<p><strong>2. 서버의 HTTP Response</strong></p>\n<p>서버는 세션 스토리지에 저장된 정보를 식별할 수 있는 세션 ID를 쿠키에 담아서 클라이언트에게 전달한다.</p>\n<p>세션 스토리지가 데이터베이스라고 한다면, 쿠키가 담고 있는 값은 단지 데이터베이스의 어떤 로우를 가리키는 PK일뿐이다. 따라서 쿠키가 탈취당해도 쿠키로부터 얻을 수 있는 정보는 없다.</p>\n<p> </p>\n<p><strong>3. HTTP with Session</strong></p>\n<p><img src=\"https://images.velog.io/images/quato/post/0b163cd3-df00-41e1-946c-e3c785ea3766/image.png\" alt=\"\"></p>\n<p>클라이언트의 두번째 요청부터는 쿠키가 함께 들어온다.</p>\n<p>서버는 쿠키를 받아서 세션 스토리지에서 세션 객체를 찾는다. 세션 객체로부터 사용자정보를 얻고 개인화된 응답을 보내준다.</p>\n<p>세션의 핵심은 HTTP 통신 상에서는 어떠한 민감한 정보도 오가지 않는다는 것이다. 민감한 정보는 오직 서버와 세션 스토리지에서만 다뤄지고 외부로 노출되지 않는다.</p>\n<p><img src=\"https://images.velog.io/images/quato/post/0b163cd3-df00-41e1-946c-e3c785ea3766/image.png\" alt=\"\"></p>\n<p> </p>\n<p><strong>세션의 한계</strong></p>\n<ul>\n<li>쿠키에 담긴 정보가 있는 그대로는 의미 없지만, 탈취한 쿠키를 이용해 서버에 요청을 보내면 정보가 유출될 수 있다. (세션 하이재킹)</li>\n<li>서버에 정보를 저장해야 하기 때문에 메모리 공간을 차지한다.</li>\n<li>쿠키로부터 받은 세션 ID로 세션 스토리지를 탐색해야 하는 시간이 든다.</li>\n<li>동시 접속자가 많은 서비스의 경우 서버 과부하의 원인이 되어, 서버에 정보를 저장하지 않는 “토큰”이 등장</li>\n</ul>\n<p> </p>\n<h2>📆   2021. 11. 23 (화)</h2>\n<h3><span>[인증/보안] 토큰, jWT</span></h3>\n<p> </p>\n<p><strong>🔐 Token</strong></p>\n<p><img src=\"https://images.velog.io/images/quato/post/43253187-5dc5-46db-99d5-65ffd2fb1b41/image.png\" alt=\"\"></p>\n<p>서버는 인증에 필요한 정보들을 암호화시켜 토큰을 발행하고, 클라이언트는 발행받은 토큰을 HTTP 헤더에 계속 넣어서 요청을 보내는 방식</p>\n<p> </p>\n<p><strong>1. 클라이언트의 인증 Request</strong></p>\n<p>클라이언트는 아이디, 패스워드 등의 인증정보를 HTTP 요청에 담아서 서버에 전달</p>\n<p> </p>\n<p><strong>2. 서버의 인증 정보 확인 및 Response + Token</strong></p>\n<p>서버는 클라이언트로부터 받은 인증 정보가 유효한지 확인하고, 토큰을 HTTP 응답에 담아서 전달</p>\n<p>토큰은 Secret Key로 암호화되어 있고, 유효기간이 설정되어 있다.</p>\n<p> </p>\n<p><strong>3. HTTP with Token</strong></p>\n<p>클라이언트는 서버로부터 발급받은 토큰을 HTTP 헤더에 담아서 요청을 보내고, 서버는 토큰이 유효한지 검사하여 인증 여부를 판별한다.</p>\n<p>토큰은 Secret Key로 복호화하여 유효한지 아닌지 판별할 수 있기 때문에 별도의 저장공간이 필요하지 않다. 따라서 세션 방식의 단점인 서버 과부하를 줄여줄 수 있다.</p>\n<p> </p>\n<p><strong>토큰의 한계</strong></p>\n<p>이미 발급된 토큰은 유효기간이 만료되기 전까지 계속 사용할 수 있기 때문에, 악의적으로 이용될 수 있다. 따라서 토큰 유효기간을 짧게 하고 Refresh Token을 새로 발급해야 한다.\n토큰의 길이가 쿠키, 세션에 비해 길어서 인증이 필요한 요청이 많을 때 서버 자원낭비가 발생한다.</p>\n<hr>\n<p> </p>\n<p><strong>🔐 JWT</strong></p>\n<p> </p>\n<p><strong>token 생성법</strong></p>\n<p>토큰을 생성하는 방법은 아래와 같다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const jwt = require(&#39;jsonwebtoken&#39;);\n\nconst userInfo = {id: 1, username: &#39;inyong&#39;};\nconst secretKey = &#39;SeCrEtKeYfOrHaShInG&#39;;\nconst options = {expiresIn: &#39;7d&#39;, issuer: &#39;inyongTest&#39;, subject: &#39;userInfo&#39;};\n\njwt.sign(userInfo, secretKey, options, \n    function(err,token){\n      if(err) console.log(err);\n      else console.log(token);\n    }\n)</code>\n        </deckgo-highlight-code>\n<p> </p>\n<p><strong>jwt.sign() 함수에 들어가는 4가지 인자 설명</strong></p>\n<ul>\n<li>userInfo : 아이디, 비밀번호 등 사용자 정보가 들어간 object이다. 형식은 상관없음.</li>\n<li>secretKey : 여러가지 복잡한 문자열로 되어있는 키.</li>\n<li>options: 토큰에 대한 여러가지 정보를 설정한다. expiresIn은 토큰 만료일, issuer, subject는 토큰에 대한 정보이다. 외에도 options가 더 있다.</li>\n<li>4번째 인자로 들어가는 익명함수 : token 생성결과를 4번째 인자의 콜백함수로 받을 수 있으므로 넣어준 함수.</li>\n</ul>\n<p> </p>\n<p><strong>token 검증 방법</strong></p>\n<p>사용자는 서버에게서 토큰을 받은 후, 서버에게 요청을 보낼 때, request.Header에 토큰을 포함하여 요청을 보낸다.</p>\n<p>그러면 서버는 사용자에게서 받은 토큰이 유효한 것인지 확인한다.</p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const secretKey = &#39;&#39;; // 아까 token 만들때 썼던 secretkey\nconst router = (req, res) =&gt; {\n  const token = req.headers[&#39;x-access-token&#39;] || req.query.token;\n  jwt.verify(token, secretKey, \n    function(err, decoded){\n      console.log(err) // 유효하지 않은 토큰\n      console.log(decoded) // 유효한 토큰, 유저 정보 Object 반환\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>jwt.verify()함수를 이용하여 토큰 유효성을 확인할 수 있다.</p>\n<p> </p>\n<p><strong>jwt.verify() 함수에 들어가는 매개변수 3개</strong></p>\n<ul>\n<li>token: client에게서 받은 token</li>\n<li>secretkey : token 생성 시 사용했던 secretKey</li>\n<li>3번째 인자로 들어간 익명함수 : 유효성 검사 결과를 처리할 callback 함수</li>\n</ul>\n<p> </p>\n<h2>📆   2021. 11. 24 (수)</h2>\n<h3><span>[인증/보안] OAuth 2.0</span></h3>\n<p> </p>\n<p><strong>🔐 OAuth 2.0</strong></p>\n<p>인증을 위한 개방형 표준 프로토콜이다.</p>\n<p>이 프로토콜에서는 Third-Party 프로그램에게 리소스 소유자를 대신하여 리소스 서버에서 제공하는 자원에 대한 접근 권한을 위임하는 방식을 제공한다.</p>\n<p>구글, 페이스북, 카카오, 네이버 등에서 제공하는 간편 로그인 기능도 OAuth2 프로토콜 기반의 사용자 인증 기능을 제공하고 있다.</p>\n<p> </p>\n<p><strong>OAuth 2.0 주요 용어</strong></p>\n<ul>\n<li>\n<p><code>Authentication</code> : 인증, 접근 자격이 있는지 검증하는 단계를 말한다.</p>\n</li>\n<li>\n<p><code>Authorization</code> :인가, 자원에 접근할 권한을 부여하는 것이다. 인가가 완료되면 리소스 접근 권한이 담긴 Access Token이 클라이언트에게 부여된다.</p>\n</li>\n<li>\n<p><code>Access Token</code> : 리소스 서버에게서 리소스 소유자의 보호된 자원을 획득할 때 사용되는 만료 기간이 있는 Token이다.</p>\n</li>\n<li>\n<p><code>Refresh Token</code> : Access Token 만료시 이를 갱신하기 위한 용도로 사용하는 Token입니다. Refresh Token은 일반적으로 Access Token보다 만료 기간이 길다.</p>\n</li>\n</ul>\n<p> </p>\n<p><strong>OAuth 2.0의 역할</strong></p>\n<p>OAuth 2.0의 요소로는 보통 다음과 같다.</p>\n<ul>\n<li><code>Client</code> : OAuth 2.0을 사용해 서드파티 로그인 기능을 구현할 자사 또는 개인 애플리케이션 서버다.</li>\n<li><code>Recource Owner</code> : 서드파티 애플리케이션 (Google, Facebook, Kakao 등)에 이미 개인정보를 저장(회원가입)하고 있으며 Client가 제공하는 서비스를 이용하려는 사용자,‘Resource’ 는 개인정보라고 생각하면 된다.</li>\n<li><code>Resource Server</code> : 사용자의 개인정보를 가지고있는 애플리케이션 (Google, Facebook, Kakao 등) 서버다. Client는 Token을 이 서버로 넘겨 개인정보를 응답 받을 수 있다.</li>\n<li><code>Authorization Server</code> : 권한을 부여(인증에 사용할 아이템을 제공주는)해주는 서버다. 사용자는 이 서버로 ID, PW를 넘겨 Authorization Code를 발급 받을 수 있다. Client는 이 서버로 Authorization Code을 넘겨 Token을 받급 받을 수 있다.</li>\n</ul>\n<p><img src=\"https://images.velog.io/images/quato/post/05bdcd7e-5767-49b8-bf8f-de033a77555e/image.png\" alt=\"\"></p>\n<p>시퀀스 다이어그램에는 refresh token이 없지만 보통 Authorization Server로 부터 access token(비교적 짧은 만료기간을 가짐) 과 refresh token(비교적 긴 만료기간을 가짐)을 함께 부여 받는다.</p>\n<p>access token은 보안상 만료기간이 짧기 때문에 얼마 지나지 않아 만료되면 사용자는 로그인을 다시 시도해야한다. 그러나 refresh token이 있다면 access token이 만료될 때 refresh token을 통해 access token을 재발급 받아 재 로그인 할 필요없게끔 한다.</p>\n<p> </p>\n<h2>📆   2021. 11. 25 (목)</h2>\n<h3><span>[컴퓨터 공학] 기초, 운영체제</span></h3>\n<p> </p>\n<p><strong>🧑🏼‍💻 문자열</strong></p>\n<p> </p>\n<p><strong>문자열 하나는 몇 바이트인가요?</strong></p>\n<p>영어의 경우 알파벳 하나가 1 바이트(byte)를 차지하는 시절이 있었습니다. 그러나 글로벌 시대에는 유니코드를 사용해야 텍스트를 정확하게 저장할 수 있습니다. 프로그래밍 언어마다 문자열을 저장하는 자료형이 다 다르므로, “문자열 하나가 몇 바이트인가?”에 대한 답변은 이 자료형이 차지하고 있는 바이트를 이해할 때 답변할 수 있습니다.</p>\n<p> </p>\n<p><strong>유니코드는 무엇인가요?</strong></p>\n<p>유니코드(Unicode)는 유니코드 협회(Unicode Consortium)가 제정하는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준입니다. 이 표준에는 ISO 10646 문자 집합, 문자 인코딩, 문자 정보 데이터베이스, 문자를 다루기 위한 알고리즘 등을 포함하고 있습니다.</p>\n<p>유니코드가 탄생하기 이전에는, 같은 한글이 적힌 텍스트 파일이라도 표현하는 방법이 제각각이었습니다. 어떤 파일이 지원하지 않는 다른 인코딩 형식으로 저장되어 있는 경우에는 파일을 제대로 불러올 수 없었습니다. 기본적으로 유니코드의 목적은 현존하는 문자 인코딩 방법을 모두 유니코드로 교체하는 겁니다.</p>\n<p> </p>\n<p><strong>인코딩(부호화)이란?</strong></p>\n<p>인코딩이란 어떤 문자나 기호를 컴퓨터가 이용할 수 있는 신호로 만드는 것입니다.\n이 신호를 입력하는 인코딩과 문자를 해독하는 디코딩을 하기 위해서는 미리 정해진 기준을 바탕으로 입력과 해독이 처리되어야 합니다.\n이렇게 인코딩과 디코딩의 기준을 문자열 세트 또는 문자셋(charset)이라고 합니다. 이 문자셋의 국제 표준이 유니코드입니다.</p>\n<p> </p>\n<p><strong>ASCII 문자는 무엇인가요?</strong></p>\n<p>영문 알파벳을 사용하는 대표적인 문자 인코딩으로 7 비트로 모든 영어 알파벳을 표현할 수 있습니다. 52개의 영문 알파벳 대소문자와, 10개의 숫자, 32개의 특수 문자, 그리고 하나의 공백 문자를 포함합니다.</p>\n<p>유니코드는 ASCII를 확장한 형태입니다.</p>\n<p> </p>\n<p><strong>UTF-8과 UTF-16의 차이점은 무엇인가요?</strong></p>\n<p>UTF-8과 UTF-16은 인코딩 방식의 차이를 의미합니다. UTF-8은 Universal Coded Character Set + Transformation Format – 8-bit의 약자로, UTF- 뒤에 등장하는 숫자는 비트(bit)입니다.</p>\n<p> </p>\n<p><strong>1. UTF-8 특징: 가변 길이 인코딩</strong></p>\n<p>UTF-8은 유니코드 한 문자를 나타내기 위해 1 byte(= 8 bits)에서 4 bytes까지 사용합니다.</p>\n<p> </p>\n<p><strong>원리</strong></p>\n<p>예를 들어, 코 라는 문자의 유니코드는 U+CF54 (16진수, HEX)로 표현됩니다. 이 문자를 이진법(binary number)으로 표시하면, 1100-1111-0101-0100 이 됩니다. 이 문자를 UTF-8로 표현하면, 다음과 같이 3byte의 결과로 표현됩니다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">1110xxxx 10xxxxxx 10xxxxxx //  x 안에 순서대로 값을 채워넣습니다.\n11101100 10111101 10010100</code>\n        </deckgo-highlight-code>\n<center>[데이터] UTF-8로 표현된 '코'</center>\n<p> </p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">let encoder = new TextEncoder(); // 기본 인코딩은 &#39;utf-8&#39;\nencoder.encode(&#39;코&#39;) // Uint8Array(3) [236, 189, 148]\n\n(236).toString(2) // &quot;11101100&quot;\n(189).toString(2) // &quot;10111101&quot;\n(148).toString(2) // &quot;10010100&quot;</code>\n        </deckgo-highlight-code>\n<p>ASCII 코드는 7비트로 표현되고, UTF-8에서는 다음과 같이 1 byte의 결과로 만들 수 있습니다. 다음 예제는 b 라는 문자를 UTF-8로 인코딩한 결과입니다.</p>\n<deckgo-highlight-code language=\"bash\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">0xxxxxxx\n01100010</code>\n        </deckgo-highlight-code>\n<center>[데이터] UTF-8로 표현된 'b'</center>\n<p> </p>\n<deckgo-highlight-code language=\"js\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">encoder.encode(&#39;b&#39;) // Uint8Array [98]\n(98).toString(2) // &quot;1100010&quot;</code>\n        </deckgo-highlight-code>\n<center>[코드] 'b'라는 문자를 UTF-8로 표현할 수 있습니다.</center>\n<p> </p>\n<p>이처럼, UTF-8은 1 byte에서 4 bytes까지의 가변 길이를 가지는 인코딩 방식입니다. 네트워크를 통해 전송되는 텍스트는 주로 UTF-8로 인코딩됩니다. 사용된 문자에 따라 더 작은 크기의 문자열을 표현할 수 있기 때문입니다. ASCII 문자는 1 바이트만으로 표현 가능한 것처럼 말입니다.\nUTF-8은 ASCII 코드의 경우 1 byte, 크게 영어 외 글자는 2byte, 3byte, 보조 글자는 4byte를 차지합니다. 이모지는 보조 글자에 해당하기 때문에 4byte가 필요합니다.</p>\n<p> </p>\n<p><strong>2. UTF-8 특징: 바이트 순서가 고정됨</strong></p>\n<p>UTF-16에 비해 바이트 순서를 따지지 않고, 순서가 정해져 있습니다.</p>\n<p> </p>\n<p><strong>3. UTF-16 특징: 코드 그대로 바이트로 표현 가능, 바이트 순서가 다양함</strong></p>\n<p>UTF-16은 유니코드 코드 대부분(U+0000부터 U+FFFF; BMP) 을 16 bits로 표현합니다.</p>\n<p>대부분에 속하지 않는 기타 문자는 32 bit(4 bytes)로 표현하므로 UTF-16도 가변 길이라고 할 수 있으나, 대부분은 2 바이트로 표현합니다</p>\n<p>U+ABCD라는 16진수를 있는 그대로 이진법으로 변환하면 1010-1011-1100-1101 입니다. 이 이진법으로 표현된 문자를 16 bits(2 bytes)로 그대로 사용하며, 바이트 순서(엔디언)에 따라 UTF-16의 종류도 달라집니다.</p>\n<p>UTF-8에서는 한글은 3 바이트, UTF-16에서는 2 바이트를 차지합니다.</p>\n<hr>\n<p> </p>\n<p><strong>🧑🏼‍💻 그래픽</strong></p>\n<p> </p>\n<p><strong>비트맵(래스터)과 벡터 이미지의 차이점</strong></p>\n<p> </p>\n<table>\n<thead>\n<tr>\n<th>기본값</th>\n<th>비트맵(래스터)</th>\n<th>벡터</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>기반 기술</td>\n<td>픽셀 기반</td>\n<td>수학적으로 계산된 Shape 기반</td>\n</tr>\n<tr>\n<td>특징</td>\n<td>사진과 같이 색상의 조합이 다양한 이미지에 적합</td>\n<td>로고, 일러스트와 같이 제품에 적용되는 이미지에 적합</td>\n</tr>\n<tr>\n<td>확대</td>\n<td>확대에 적합하지 않음, 보다 큰 사이즈의 이미지가 필요할 때 사용하려는 크기 이상으로 생성하거나 스캔해야 함</td>\n<td>품질 저하 없이 모든 크기로 확대 가능하며, 해상도의 영향을 받지 않음</td>\n</tr>\n<tr>\n<td>크기(dimension)에 따른 파일 용량(file size)</td>\n<td>큰 크기의 이미지는, 큰 파일 사이즈를 가짐</td>\n<td>큰 크기의 벡터 그래픽은 작은 파일 사이즈를 유지할 수 있음</td>\n</tr>\n<tr>\n<td>상호 변환</td>\n<td>이미지의 복잡도에 따라 벡터로 변환하는 것에 오랜 시간이 걸림</td>\n<td>쉽게 래스터 이미지로 변환 가능</td>\n</tr>\n<tr>\n<td>대표적인 파일 포맷</td>\n<td>jpg, gif, png, bmp, psd</td>\n<td>svg, ai</td>\n</tr>\n<tr>\n<td>웹에서의 사용성</td>\n<td>jpg, gif, png 등이 널리 쓰임</td>\n<td>svg 포맷은 현대의 브라우저에서 대부분 지원</td>\n</tr>\n</tbody>\n</table>\n<center>[표] 비트맵(래스터) 이미지와 벡터 이미지의 차이점</center>\n<p> </p>\n<hr>\n<p> </p>\n<p><strong>🧑🏼‍💻 운영체제</strong></p>\n<p>컴퓨터나 스마트폰의 기기 그 자체(하드웨어)는 스스로 할 수 있는 일이 없습니다. 하드웨어의 설계를 바탕으로 하드웨어에게 일을 시켜야만 그 의미가 있습니다. 하드웨어에게 일을 시키는 주체가 바로 운영체제입니다. 이번 시간에서는 운영체제가 하는 일을 소개합니다.</p>\n<p> </p>\n<p><strong>1. 운영체제</strong></p>\n<p><strong>시스템 자원 관리</strong></p>\n<p>운영체제가 없다면, 응용 프로그램이 실행될 수 없습니다. 응용 프로그램은 컴퓨터를 이용해 다양한 작업을 하는 것이 목적인고, 운영체제는 응용 프로그램이 하드웨어에게 일을 시킬 수 있도록 도와줍니다. 하드웨어를 구성하는 일을 하는 CPU, 자료를 저장하는 RAM, 디스크 등의 시스템 자원을 관리하는 주체가 바로 운영체제입니다.</p>\n<ul>\n<li>프로세스 관리(CPU)</li>\n<li>메모리 관리</li>\n<li>I/O(입출력) 관리 (디스크, 네트워크 등)</li>\n</ul>\n<p> </p>\n<p><strong>운영체제의 구조 모식도</strong></p>\n<p><img src=\"https://images.velog.io/images/quato/post/48f5fdcf-3e50-42ab-aeb1-34f141c0ab8e/image.png\" alt=\"\"></p>\n<center>[그림] 운영체제의 구조 모식도</center>\n<p> </p>\n<p><strong>응용 프로그램 관리</strong></p>\n<p>모든 응용 프로그램이 시스템의 자원을 마음대로 사용한다면, 해커에 의한 공격에 무방비한 상태가 됩니다. 악의적인 목적을 가진 프로그램이 디스크의 모든 민감한 정보에 접근하거나, 내 스마트폰의 특정 앱이 카메라를 아무 때나 실행해서 촬영한다고 생각하면 끔찍합니다. 따라서, 응용 프로그램은 권한에 대한 관리가 필요합니다. 또한 여러 사람이 하나의 기기를 사용하는 경우에는 사용자를 관리하는 일도 매우 중요합니다.</p>\n<p>응용 프로그램이 실행되고, 시스템 자원을 사용할 수 있도록 권한과 사용자를 관리합니다.</p>\n<p> </p>\n<p><strong>2. 응용 프로그램: 운영체제를 통해 컴퓨터에게 일을 시키는 것</strong></p>\n<p>응용 프로그램이 운영체제를 통해 컴퓨터에게 일을 시키려면, 컴퓨터를 조작할 수 있는 권한을 운영체제로부터 부여받아야 합니다. 권한을 부여받고 난 후에는, 운영체제가 제공하는 기능을 이용할 수 있습니다. 응용 프로그램이 운영체제와 소통하기 위해서는, 운영체제가 응용 프로그램을 위해 인터페이스(API)를 제공해야 합니다. 응용 프로그램이 시스템 자원을 사용할 수 있도록, 운영체제 차원에서 다양한 함수를 제공하는 것을 시스템 콜(System call)이라고 부릅니다.</p>\n<p>스마트폰에서 사용자에게 어떤 디바이스(카메라 등)의 사용을 허락받는 화면을 본 적이 있을 겁니다. 이와 마찬가지로, 응용 프로그램 역시 운영체제가 프린터 사용을 허가해 주지 않는다면 사용할 수 없습니다. 워드프로세서 프로그램이 프린터를 사용해서 인쇄하기 위해서는, 워드프로세서 프로그램은 운영체제로부터 프린터 사용에 대한 권한을 부여받아야 합니다.</p>\n<p>응용 프로그램이 프린터 사용에 대한 권한을 획득한 후에는, 프린터를 사용할 때 필요한 API를 호출해야 합니다. 이 API는 시스템 콜로 이루어져 있습니다.</p>\n<hr>\n<p> </p>\n<p><strong>🧑🏼‍💻 프로세스, 스레드, 멀티 스레드</strong></p>\n<p><strong>1. 프로세스(Process)</strong></p>\n<p>운영체제에서는 실행 중인 하나의 애플리케이션을 프로세스라고 부릅니다. 사용자가 애플리케이션을 실행하면, 운영체제로부터 실행에 필요한 메모리를 할당받아 애플리케이션의 코드를 실행합니다. 이때 실행되는 애플리케이션을 프로세스라고 부릅니다. 예를 들어 Chrome 브라우저를 두 개 실행하면, 두 개의 프로세스가 생성됩니다. 이렇게 하나의 애플리케이션은 여러 프로세스(다중 프로세스)를 만들기도 합니다.</p>\n<p>다음 사진에서 확인할 수 있는 항목 하나하나가 전부 프로세스입니다.</p>\n<p><img src=\"https://images.velog.io/images/quato/post/3508e297-91db-478c-85fd-5347248bc01f/image.png\" alt=\"\"></p>\n<center>[그림] 활성 상태창(macOS, Windows에서는 작업관리자) 예시</center>\n<p> </p>\n<p><strong>2. 스레드(Thread)</strong>\n스레드는 사전적 의미로 한 가닥의 실이라는 뜻입니다. 한 가지 작업을 실행하기 위해 순차적으로 실행한 코드를 실처럼 이어 놓았다고 해서 유래된 이름입니다. 하나의 스레드는 코드가 실행되는 하나의 흐름이기 때문에, 한 프로세스 내에 스레드가 두 개라면 코드가 실행되는 흐름이 두 개 생긴다는 의미입니다.</p>\n<p> </p>\n<p><strong>3. 멀티 스레드(Multi-Thread)</strong></p>\n<p>멀티 태스킹은 두 가지 이상의 작업을 동시에 처리하는 것을 의미합니다. 운영체제는 멀티 태스킹을 할 수 있도록, 프로세스마다 CPU 및 메모리 자원을 적절히 할당하고 병렬로 실행합니다. 예를 들어 워드로 문서작업을 하면서, 동시에 Chrome 브라우저에서 음악을 들을 수 있습니다. 물론 멀티 태스킹은 꼭 멀티 프로세스를 의미하는 것은 아닙니다. 하나의 프로세스 내에서 멀티 태스킹을 할 수 있도록 만들어진 애플리케이션도 있습니다. 하나의 프로세스가 어떻게 두 가지 이상의 작업을 처리할 수 있을까요? 그 비밀은 멀티 스레드에 있습니다.</p>\n<p>멀티 프로세스가 애플리케이션 단위의 멀티 태스킹이라면, 멀티 스레드는 애플리케이션 내부에서의 멀티 태스킹이라고 할 수 있습니다.</p>\n<p>멀티 스레드는 다양한 곳에서 사용됩니다. 대용량 데이터의 처리시간을 줄이기 위해 데이터를 분할하여 병렬로 처리하는 데에 사용할 수도 있고, UI를 가지고 있는 애플리케이션에서 네트워크 통신을 하기 위해 사용할 수도 있습니다. 그리고 여러 클라이언트의 요청을 처리하는 서버를 개발할 때에도 사용됩니다.</p>\n<p><img src=\"https://images.velog.io/images/quato/post/1b633793-877d-4c1c-9924-5c745b26fe67/image.png\" alt=\"\"></p>\n<center>[그림] 프로세스와 멀티 스레드 예시</center>\n<hr>\n<p> </p>\n<p><strong>🧑🏼‍💻 멀티 스레드</strong></p>\n<p><img src=\"https://images.velog.io/images/quato/post/d4d998ff-4aeb-4217-95d1-8a9778ac4e4e/image.png\" alt=\"\"></p>\n<center>[그림] 프로세스와 스레드 구성</center>\n<p> </p>\n<p><strong>1. 스레드의 특징</strong></p>\n<ul>\n<li>프로세스 내에서 실행되는 흐름의 단위</li>\n<li>각 스레드마다 call stack이 존재(call stack: 실행 중인 서브루틴을 저장하는 자료 구조)</li>\n<li>스레드는 다른 스레드와 독립적으로 동작</li>\n</ul>\n<p> </p>\n<p><strong>2. 멀티 스레딩의 장점</strong></p>\n<p>프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우, 메모리 공간과 시스템 자원의 소모가 줄어듭니다. 스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라, 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용합니다. 따라서, 프로세스 간 통신 방법(IPC)에 비해 스레드 간의 통신 방법이 훨씬 간단합니다. 시스템의 처리량(Throughput)이 향상되고 자원 소모가 줄어들어 자연스럽게 프로그램의 응답 시간이 단축됩니다. 이런 장점 때문에 여러 프로세스로 할 수 있는 작업을 하나의 프로세스에서 스레드로 나눠 수행합니다.</p>\n<p> </p>\n<p><strong>3. 멀티 스레딩의 문제점</strong></p>\n<p>멀티 프로세스 기반으로 프로그래밍할 때에는 프로세스 간 공유하는 자원이 없습니다. 따라서 동일한 자원에 동시에 접근하는 일이 없었지만, 멀티 스레딩을 기반으로 프로그래밍할 때에는 공유하는 자원에 대하여 고민이 필요합니다. 서로 다른 스레드가 같은 데이터에 접근하고, 힙 영역을 공유하기 때문에 서로 다른 스레드가 서로 사용 중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정하는 일이 발생할 수 있습니다.</p>\n<p>그렇기 때문에 멀티스레딩 환경에서는 동기화 작업이 필요합니다. 동기화를 통해 작업 처리 순서를 제어하고, 공유 자원에 대한 접근을 제어해야 합니다.</p>\n<p>관련 키워드</p>\n<ul>\n<li>데드락(Deadlock, 교착 상태)</li>\n<li>뮤텍스(Mutex), 세마포어(Semaphore)</li>\n</ul>\n<p> </p>\n<p><strong>4. 동시성과 병렬성의 차이</strong></p>\n<p><img src=\"https://images.velog.io/images/quato/post/a0f40a59-7c64-4752-b9ce-fb09e7364d6a/image.png\" alt=\"\"></p>\n<center>[그림] 싱글 코어와 멀티 코어 예시</center>\n<p> </p>\n<p>동시에 돌릴 수 있는 스레드 수는 컴퓨터에 있는 코어 개수로 제한됩니다. 운영체제(또는 가상 머신)는 각 스레드를 시간에 따라 분할하여, 여러 스레드가 일정 시간마다 돌아가면서 실행되도록 합니다. 이런 방식을 시분할이라고 합니다.\nConcurrency(동시성, 병행성): 여러 개의 스레드가 시분할 방식으로 동시에 수행되는 것처럼 착각을 불러일으킴\nParallelism(병렬성): 멀티 코어 환경에서 여러 개의 스레드가 실제로 동시에 수행됨</p>\n<p> </p>\n<p><strong>5. Context Switching이란?</strong></p>\n<p>다른 태스크(프로세스, 스레드)가 시작할 수 있도록 이미 실행 중인 태스크(프로세스, 스레드)를 멈추는 것을 Context Switching이라고 합니다.</p>\n<p> </p>\n<h2>📆   2021. 11. 26 (금)</h2>\n<h3><span>[컴퓨터 공학] 가비지 컬렉션, 캐시</span></h3>\n<p> </p>\n<p><strong>가비지 컬렉션</strong></p>\n<p> </p>\n<p><strong>1. 가비지 컬렉션은 무엇이며, 가비지 컬렉션 기능을 가진 언어는 무엇인가요?</strong></p>\n<p>가비지 컬렉션은 프로그램에서 더 이상 사용하지 않는 메모리를 자동으로 정리하는 것입니다. 이 기능을 가진 언어(혹은 엔진)는 자바, C#, 자바스크립트 등이 있습니다.</p>\n<p> </p>\n<p><strong>2. 대표적인 가비지 컬렉션의 방법은 무엇이 있나요?</strong></p>\n<ul>\n<li>트레이싱: 한 객체에 flag를 두고, 가비지 컬렉션 사이클마다 flag에 표시 후 삭제하는 mark and sweep 방법입니다.\n객체에 in-use flag를 두고, 사이클마다 메모리 관리자가 모든 객체를 추적해서 사용 중인지 아닌지를 표시(mark)합니다. 그 후 표시되지 않은 객체를 삭제(sweep)하는 단계를 통해 메모리를 해제합니다.</li>\n<li>레퍼런스 카운팅: 한 객체를 참조하는 변수의 수를 추적하는 방법입니다.\n객체를 참조하는 변수는 처음에는 특정 메모리에 대해 레퍼런스가 하나뿐이지만, 변수의 레퍼런스가 복사될 때마다 레퍼런스 카운트가 늘어납니다. 객체를 참조하고 있던 변수의 값이 바뀌거나, 변수 스코프를 벗어나면 레퍼런스 카운트는 줄어듭니다. 레퍼런스 카운트가 0이 되면, 그 객체와 관련한 메모리는 비울 수 있습니다. 레퍼런스 카운트가 0이 된다는 말은 아무도 그 객체에 대한 레퍼런스를 가지고 있지 않다는 말과 같습니다.</li>\n</ul>\n<hr>\n<p> </p>\n<p><strong>웹 서비스에서의 캐시</strong></p>\n<p><strong>1. 캐시란 무엇인가요?</strong></p>\n<p>많은 시간이나 연산이 필요한 작업의 결과를 저장해두는 것을 의미합니다.\n컴퓨팅에서 캐시는 일반적으로 일시적인(temporarily) 데이터를 저장하기 위한 목적으로 존재하는 고속의 데이터 저장 공간입니다. 첫 작업 이후에 이 데이터에 대한 요청이 있을 경우, 데이터의 기본 저장 공간에 접근할 때보다 더 빠르게 요청을 처리할 수 있습니다. 캐싱을 사용하면 이전에 검색하거나 계산한 데이터를 효율적으로 재사용할 수 있습니다.</p>\n<p> </p>\n<p><strong>2. 캐시의 일반적인 작동원리</strong></p>\n<p> </p>\n<p>캐시의 데이터는 일반적으로 RAM(Random Access Memory)과 같이 빠르게 액세스할 수 있는 하드웨어에 저장되며, 소프트웨어 구성 요소와 함께 사용될 수도 있습니다. 캐시는 기본 스토리지 계층(SSD, HDD)에 액세스하여 데이터를 가져오는 더 느린 작업의 요구를 줄이고, 데이터 검색의 성능을 높입니다.</p>\n<p>속도를 위해 용량을 절충하는 캐시는 일반적으로 데이터의 하위 집합을 일시적으로 저장합니다. 완전하고 영구적인 데이터가 있는 데이터베이스와는 대조적입니다.</p>\n<p> </p>\n<p><strong>3. 캐시의 장점은 무엇인가요?</strong></p>\n<ul>\n<li>애플리케이션 성능 개선</li>\n<li>데이터베이스 비용 절감</li>\n<li>백엔드 부하 감소</li>\n<li>예측 가능한 성능</li>\n<li>데이터베이스 핫스팟 제거</li>\n<li>읽기 처리량 증가\n<ul>\n<li>읽기 처리량: IOPS; Input/output operations per second. HDD, SSD 등의 컴퓨터 저장 장치의 성능 측정 단위</li>\n</ul>\n</li>\n</ul>\n<p> </p>\n<p><strong>4. 웹서비스에서 캐시가 적용되는 예제로는 어떤 것들이 있나요?</strong></p>\n<ul>\n<li>클라이언트: HTTP 캐시 헤더, 브라우저</li>\n<li>네트워크: DNS 서버, HTTP 캐시 헤더, CDN, 리버스 프록시</li>\n<li>서버 및 데이터베이스: 키-값 데이터 스토어(e.g. Redis), 로컬 캐시(인-메모리, 디스크)</li>\n</ul>","timeToRead":17,"frontmatter":{"title":"CodeStates IM [week 13]","summary":"CodeState Pre IM 13주차 기록입니다.","date":"22 November, 2021","category":"Codestates","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAEGBwn/xAAWAQEBAQAAAAAAAAAAAAAAAAACAwb/2gAMAwEAAhADEAAAAdhYTZq2hBk1/8QAGBABAQADAAAAAAAAAAAAAAAABAMFBiD/2gAIAQEAAQUCci5jHyWx1Rx//8QAHBEBAAEEAwAAAAAAAAAAAAAAASECETFxEBJC/9oACAEDAQE/AUX3UYg6TbdKzhs6szx//8QAGxEAAgIDAQAAAAAAAAAAAAAAAQIDIQAREiL/2gAIAQIBAT8BV1CFTDG5JqRjL2tEaHMipq+rQ+gN1Rz/xAAhEAACAgEDBQEAAAAAAAAAAAACAwEEEgURIgAGFBUgI//aAAgBAQAGPwJjq1F+ouGOFSuyspjJxKY523V0iOUCJfply3ES2nrTAb24Nau9aPaOZqSDKi01ybhrrTLPJBB7KyKQk5nKIx+f/8QAFxABAQEBAAAAAAAAAAAAAAAAAREgUf/aAAgBAQABPyFMTOwEaIWIYALXwmCyRtpZQuf/2gAMAwEAAgADAAAAEBsP/8QAGBEBAQEBAQAAAAAAAAAAAAAAARExECH/2gAIAQMBAT8QcECKRilRZ5wPNcH/xAAXEQEBAQEAAAAAAAAAAAAAAAABERAh/9oACAECAQE/EFWWQFCi4GFvQby//8QAGxABAQACAwEAAAAAAAAAAAAAAREQUQAxkUH/2gAIAQEAAT8QL2S311OpjrH4MVdtjNj0zgoSwpGFNP0xDR5rrzH/2Q=="},"images":{"fallback":{"src":"/static/5ae71771cc28d8142710f1d07c2f1e79/9d1bb/codestate-software-engineer.jpg","srcSet":"/static/5ae71771cc28d8142710f1d07c2f1e79/35c22/codestate-software-engineer.jpg 183w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/0837d/codestate-software-engineer.jpg 365w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/9d1bb/codestate-software-engineer.jpg 730w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/0a556/codestate-software-engineer.jpg 1460w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/static/5ae71771cc28d8142710f1d07c2f1e79/98c3d/codestate-software-engineer.webp 183w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/da319/codestate-software-engineer.webp 365w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/e195b/codestate-software-engineer.webp 730w,\n/static/5ae71771cc28d8142710f1d07c2f1e79/b523f/codestate-software-engineer.webp 1460w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":411}},"publicURL":"/static/5ae71771cc28d8142710f1d07c2f1e79/codestate-software-engineer.jpeg"}}}}]}},"pageContext":{"slug":"/CodeStates/2021-11-22-CodeStates IM [week 13]/"}},
    "staticQueryHashes": ["2368566813","3026479947","3227158195","413061808"]}