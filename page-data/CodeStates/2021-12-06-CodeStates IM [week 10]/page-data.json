{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/CodeStates/2021-12-06-CodeStates IM [week 10]/",
    "result": {"data":{"posts":{"edges":[{"node":{"id":"4696811c-3c1e-58a1-8372-fd0d0c72a588","html":"<h2>📆   2021. 12. 06 (월)</h2>\n<h3><span>[AWS] 배포 자동화</span></h3>\n<p> </p>\n<p><strong>CodeDeploy란?</strong></p>\n<p>CodeDeploy는 EC2, Lambda, On-Premise 등 다양한 컴퓨팅 서비스에 대한 배포를 자동화하는 완전 관리형 배포 서비스이다. AWS에서 완전히 관리해주는 서비스이기 때문에 신속하고 안전하게 배포가 가능하다. 또한 배포 방식도 다양하게 구성할 수 있는데 배포중인 애플리케이션이 완전히 다운되는 것을 막기 위해 최소한의 구동되고 있어야 할 인스턴스 퍼센트를 정의한다거나 Blue/Green Deployment를 수행하는 등의 과정으로 가동 중지 시간을 최소화할 수 있다.</p>\n<p>CodeDeploy를 사용하기 위해서는 먼저 인프라를 프로비저닝해야 한다. Deployment에서 인프라를 자동으로 생성해주지는 않기 때문에 내가 어디에 이 애플리케이션을 배포할 것인지, 어떤 환경에 배포할 것인지 등을 정하여 미리 생성해두어야 한다. 그 후 배포하고자 하는 환경에 CodeDeploy Agent를 설치해야 한다. 설치된 agent가 지속적으로 CodeDeploy를 polling 하면서 새로 배포해야 할 정보들을 받아온다. 그 후 배포할 애플리케이션의 코드와 appspec.yml을 github 혹은 S3에 업로드한다. 여기까지 Deployment를 생성하기 위한 사전 설정이 끝났다면 CodeDeploy application을 생성한다. 그리고 배포를 수행할 배포 그룹을 설정하고 앞에서 프로비저닝한 인프라를 지정해준다. 배포 생성 후 Deploy를 생성하여 수행하면 정의한 appspec.yml에 따라 동작하며 배포한다.</p>\n<p>배포 그룹을 설정하는 과정에서 생성한 인스턴스를 태그 등으로 구분할 수 있다. 여기서 CodeDeploy의 큰 장점이 등장한다. 인스턴스마다 Test, Prod, Dev 등 다양한 태그를 설정해놓은 후 각 태그별로 배포 그룹을 생성하면 각 용도에 맞는 배포 환경을 설정할 수 있다. 즉 인스턴스를 태그로 구분하여 그룹을 생성하고 각 그룹에 맞는 배포 환경을 따로 설정할 수 있다. 예를 들어 개발 환경의 경우 빠르게 결과를 확인하거나 동작 확인을 하기 위해 구성하였으므로 실제 애플리케이션 사용자에게 영향을 미치지 않기 때문에 인스턴스가 잠시 모두 다운되어도 괜찮다. 따라서 여러 인스턴스를 한번에 배포하는 ‘AllatOnce’로 선택하여 한번에 수행하도록 설정한다. 반면 Prod의 경우 실제 사용자에게 제공되는 배포 환경으로, 끊김없이 지속되어야 한다. 따라서 인스턴스 하나씩 배포하여 안정적인 상태를 유지하는 ‘OneatOnce’로 선택한다. 물론 이 외에도 원하는 만큼 인스턴스를 유지하도록 설정하는 등 다른 형태로도 배포가 가능하다.</p>\n<p>CodeDeploy 역시 CloudWatch와 함께 사용할 수 있다. event의 경우 deploy가 실패했을 때 slack 알람을 가도록 설정한다던지, state가 변경될 때마다 스트림 분석을 위해 kinesis로 전송한다는 등의 설정을 할 수 있다. Logs의 경우 인스턴스에 CloudWatch log agent를 추가로 설치해야 하며 로그 정보를 확인할 수 있다.</p>\n<p>배포가 실패하거나 설정한 알람이 울리는 경우 rollback 기능도 지원한다. 새로 배포한 인스턴스가 아얘 시작 자체가 안되거나 급격히 리소스 사용량이 많아지는 등 문제 상황이 발생했을 시 안정적인 버전의 애플리케이션을 다시 배포하기 위해 롤백한다.</p>\n<p> </p>\n<p><strong>CodeDeploy 동작 구조</strong></p>\n<p><img src=\"https://images.velog.io/images/quato/post/9871ce48-ca03-4cd9-8ec3-8fe5e3fd2440/image.png\" alt=\"\">{: .align-center}</p>\n<p><strong>1️.</strong> 소스코드와 appspec.yml을 리포지토리에 push한다.</p>\n<p><strong>2️.</strong> deployment를 트리거한다.</p>\n<p><strong>3️.</strong> CodeDeploy를 polling하고있던 EC2 인스턴스는 트리거를 확인한다.</p>\n<p><strong>4️.</strong> 리포지토리에서 소스코드와 appspec.yml 파일을 받아와 deployment 명령을 수행한다.</p>\n<p> </p>\n<p><strong>appspec.yml</strong></p>\n<p><img src=\"https://images.velog.io/images/quato/post/ae577a50-16a3-4b1b-8113-1b21877e750e/image.png\" alt=\"\">{: .align-center}</p>\n<p>Deployment 명령어에 해당하는 appspec.yml 파일 형태는 위와 같다. 배포할 소스코드의 위치와 새로 저장 할 위치를 지정한 후 hooks을 지정한다. hooks은 배포 과정 단계에서 각각 수행해야 할 명령어들을 정의한 것이다. 보통 쉘 스크립트로 정의하며 당연히 해당 스크립트 파일도 함께 S3 혹은 Github에 존재해야한다. 각각의 hooks 단계에서 정의해야 할 동작은 아래와 같다.</p>\n<p><img src=\"https://images.velog.io/images/quato/post/e0fcb8a3-e705-4173-b25e-1cebb6d2a257/image.png\" alt=\"\">{: .align-center}</p>\n<ul>\n<li>BeforeInstall 대체 작업 세트가 생성되기 전에 작업을 실행하려면 이 항목을 사용한다. 대상 그룹 하나가 원래 작업 세트와 연결된다. 테스트 리스너가 지정된 경우 원래 작업 세트와 연결된다. 이 시점에서는 롤백이 불가능하다.</li>\n<li>AfterInstall 대체 작업 세트가 생성되고 대상 그룹 중 하나가 연결된 후 작업을 실행하면 이 항목을 사용한다. 테스트 리스너가 지정된 경우 원래 작업 세트와 연결된다. 이 수명 주기 이벤트에서 후크 함수의 결과는 롤백을 트리거할 수 있다.</li>\n<li>AfterAllowTestTraffic 테스트 리스너가 대체 작업 세트에 트래픽을 제공한 후 작업을 실행하려면 이 항목을 사용한다. 이 시점에서 후크 함수의 결과는 롤백을 트리거할 수 있다.</li>\n<li>BeforeAllowTraffic 두 번째 대상 그룹이 대체 작업 세트와 연결된 후 트래픽이 대체 작업 세트로 전환되기 전에 작업을 실행하려면 이 항목을 사용한다. 이 수명 주기 이벤트에서 후크 함수의 결과는 롤백을 트리거할 수 있다.</li>\n<li>AfterAllowTraffic 두 번째 대상 그룹이 대체 작업 세트에 트래픽을 제공한 후 작업을 실행하려면 이 항목을 사용한다. 이 수명 주기 이벤트에서 후크 함수의 결과는 롤백을 트리거할 수 있다.</li>\n</ul>\n<p> </p>\n<h2>📆   2021. 12. 07 (화)</h2>\n<h3><span>[HA] day 1</span></h3>\n<p> </p>\n<p>드디어 마지막 HA가 오늘부터 시작된다. Section 2와 마찬가지로 이틀 동안 진행되며 첫날은 코플릿, 둘째 날은 과제형으로 진행된다. 조금 달라진 점이라면 이번 기수부터 과제형과 함께 퀴즈도 추가되었다는 점 정도이다. 퀴즈는 1시간 동안 20문제를 풀어야 한다고 되어있는데 난이도가 확실하지 않아 걱정된다.</p>\n<p>코플릿 풀이는 총 3문제로 구성되었다. 첫 번째 문제는 색종이의 가로와 세로 길이를 주며 색종이를 모두 사용하여 만들 수 있는 정사각형의 최대 크기를 구하는 문제였다. 문제를 읽고 난 후 최대공약수를 이용하여 푸는 문제라고 판단했다. Section 3 초반 자료구조/알고리즘에서 학습했던 유클리드 호제법을 이용하여 어렵지 않게 풀 수 있었다.</p>\n<p>두 번째 문제는 자연수 n과 m이 주어지며 1~n으로 만들 수 있는 M개의 수열을 반환하는 문제였다. 처음에는 순열을 이용하여 푸는 것으로 파악했으나 문제 해결의 실마리가 보이지 않아 재귀를 이용하여 풀어주었다. 중간에 하드코딩이 들어가 아쉬움이 남았다.</p>\n<p>세 번째 문제는 첫 번째 문제와 마찬가지로 자료구조/알고리즘에서 학습했던 보드판 문제의 변형이 출제되었다. 저번 문제와 다른 점이라면 보드판 밖으로 나간 경우 바로 ‘out’을 반환하는 것이 아니라 해당 이동을 무시하고 다음 이동을 진행한다는 것과 0과 1로 이루어졌던 저번 배열과 달리 다양한 숫자로 이루어진 배열로 이루어져 있다는 점이었다. 배열의 값들은 어렵지 않게 처리할 수 있었으나 배열 밖으로 이동 시 무시한다는 개념을 코드로 구현하는 데 어려움을 겪었다. 결국 해당 이동의 반대로 한 번 더 이동하는 코드를 작성했는데 다른 풀이법이 있을 것 같은 느낌이 들어 찝찝했다.</p>\n<p>결론적으로 3문제 모두 테스트는 통과가 되었다. 코드 작성에는 아쉬움이 남았지만 레퍼런스가 공개되지 않는 만큼 이후 개인적으로 알아보는 방향으로 학습을 진행할 예정이다.</p>\n<p> </p>\n<h2>📆   2021. 12. 08 (수)</h2>\n<h3><span>[HA] day 2</span></h3>\n<p> </p>\n<p>HA 두 번째 날이다. 1시간 동안 퀴즈를 풀고 오후 6시까지 과제형을 풀었다. 퀴즈의 난이도는 생각보다 어렵지 않았으나 헷갈리는 문제가 있었다. 총 20문제 중 18문제를 맞췄는데 시간복잡도 2문제를 모두 틀렸다. 아직 답이 이해가 되지 않는다. 내가 잘못 알고 있는게 있는 것 같다.</p>\n<p>과제형은 토큰을 이용한 인증 문제로 클라이언트와 서버를 모두 구현해보는 것이다. 스프린트에서 풀었던 것과 차이가 있었는데 login.js에서 토큰을 생성하고 쿠키를 전달했던 방식과 달리 파일을 분리하여 개별 과정이 진행되었다. 문제가 생각보다 풀리지 않아 클라이언트부터 마무리하고 서버로 다시 돌아와 마저 풀어주었다. 다른 테스트들은 통과가 되었는데 마지막 1개가 아무리해도 풀리지 않아 그대로 제출하게 되었다. 아직 인증부분에서의 학습이 더 필요해보인다.</p>","timeToRead":4,"frontmatter":{"title":"CodeStates IM [week 15]","summary":"CodeState Pre IM 15주차 기록입니다.","date":"06 December, 2021","category":"Codestates","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAcGCP/EABYBAQEBAAAAAAAAAAAAAAAAAAECA//aAAwDAQACEAMQAAAB4JXqKaGQW8X/AP/EABoQAAIDAQEAAAAAAAAAAAAAAAMEAQUGABL/2gAIAQEAAQUCumLwupRQ0DHEaj3saSoYhCqQUKJReR//xAAdEQACAgIDAQAAAAAAAAAAAAABAhESIVEAMXHh/9oACAEDAQE/AUAupctSwuFMMUnIWZUNEgGpHWN20Me/Of/EAB8RAAICAQQDAAAAAAAAAAAAAAECAxESAAQTIUFxkf/aAAgBAgEBPwHcsZNrJHCFjm4iscpBpZVAKM/GUkZMwORVkUuuS5C9C6F0TQsjoX5od19PvX//xAAjEAACAgICAQQDAAAAAAAAAAABAwIEERIFIQAGExRRFSKB/9oACAEBAAY/Auco1+d5OmhLnuSF/PsoUvCJQWEUVvZGJi7qQUYRxg42HlwK9RflppqStTr3uO52udKzB78UvucctMWlU9sOYrMQT1rknseC+7j6s7jHBbLHtgTZAK6DNcCeBCIBkCQAADjyTq1f47dZR3UxqzrPqY/WY6kOpfY6PkTJMJH7kNj/AEyyT5//xAAbEAEBAQEBAAMAAAAAAAAAAAABESEAMUFxgf/aAAgBAQABPyFvoAGQOOLfNSc4cEjVM5/eaSewjWKW466X4fTpkR9dDMSWJDHBOTPqacSA+4M6GBNu9fV+pe//2gAMAwEAAgADAAAAEPjf/8QAGREBAQADAQAAAAAAAAAAAAAAAREAITFB/9oACAEDAQE/EK+bF0gsYVkCN0cIrQpghQuhQCzqAL4cz//EABgRAQEAAwAAAAAAAAAAAAAAAAERACEx/9oACAECAQE/EE2XopVgJQ0NkJBhAikFIoLUFAgprn//xAAYEAEBAQEBAAAAAAAAAAAAAAABEQAhMf/aAAgBAQABPxCQHxNvcc8g0BDu4stzhR9dQwGKAsSt0hE5RGdzHDFVXUQJfQxyVdZvo3KWCYTaKSQyVSHguCAwDf/Z"},"images":{"fallback":{"src":"/static/7743b7c59f0690d037cf8cbb1aabfe84/9d1bb/codestate-software-engineer.jpg","srcSet":"/static/7743b7c59f0690d037cf8cbb1aabfe84/35c22/codestate-software-engineer.jpg 183w,\n/static/7743b7c59f0690d037cf8cbb1aabfe84/0837d/codestate-software-engineer.jpg 365w,\n/static/7743b7c59f0690d037cf8cbb1aabfe84/9d1bb/codestate-software-engineer.jpg 730w,\n/static/7743b7c59f0690d037cf8cbb1aabfe84/0a556/codestate-software-engineer.jpg 1460w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/static/7743b7c59f0690d037cf8cbb1aabfe84/98c3d/codestate-software-engineer.webp 183w,\n/static/7743b7c59f0690d037cf8cbb1aabfe84/da319/codestate-software-engineer.webp 365w,\n/static/7743b7c59f0690d037cf8cbb1aabfe84/e195b/codestate-software-engineer.webp 730w,\n/static/7743b7c59f0690d037cf8cbb1aabfe84/b523f/codestate-software-engineer.webp 1460w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":411}},"publicURL":"/static/7743b7c59f0690d037cf8cbb1aabfe84/codestate-software-engineer.jpeg"}}}}]}},"pageContext":{"slug":"/CodeStates/2021-12-06-CodeStates IM [week 10]/"}},
    "staticQueryHashes": ["2368566813","3026479947","3227158195","413061808"]}